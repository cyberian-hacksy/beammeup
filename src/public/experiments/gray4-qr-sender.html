<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>4-Level Grayscale QR Sender - Experiment</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: system-ui, sans-serif;
      background: #1a1a2e;
      color: #e0e0e0;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
    }
    h1 { margin-bottom: 10px; color: #00d4ff; }
    .description {
      max-width: 600px;
      text-align: center;
      margin-bottom: 20px;
      color: #aaa;
    }
    .composite-section {
      text-align: center;
      margin-top: 20px;
    }
    .composite-section h2 {
      margin-bottom: 15px;
      color: #00d4ff;
    }
    #compositeCanvas {
      border: 3px solid #00d4ff;
      border-radius: 8px;
    }
    .legend {
      display: flex;
      gap: 20px;
      margin-top: 20px;
      flex-wrap: wrap;
      justify-content: center;
    }
    .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 14px;
    }
    .legend-box {
      width: 30px;
      height: 30px;
      border: 1px solid #555;
      border-radius: 4px;
    }
    .data-display {
      margin-top: 20px;
      padding: 15px;
      background: #252540;
      border-radius: 8px;
      max-width: 500px;
      font-family: monospace;
      font-size: 12px;
    }
    .note {
      margin-top: 15px;
      padding: 10px;
      background: #252540;
      border-radius: 8px;
      font-size: 12px;
      color: #888;
      max-width: 500px;
      text-align: center;
    }
  </style>
</head>
<body>
  <h1>4-Level Grayscale QR - Sender</h1>
  <p class="description">
    Instead of binary QR, each module encodes 2 bits using 4 gray levels.
    This doubles data density but requires distinguishing 4 brightness levels.
  </p>

  <div class="composite-section">
    <h2>4-Level Grayscale QR Code</h2>
    <canvas id="compositeCanvas" width="400" height="400"></canvas>
  </div>

  <div class="legend">
    <div class="legend-item">
      <div class="legend-box" style="background: #000000;"></div>
      <span>00 (Black)</span>
    </div>
    <div class="legend-item">
      <div class="legend-box" style="background: #555555;"></div>
      <span>01 (Dark)</span>
    </div>
    <div class="legend-item">
      <div class="legend-box" style="background: #aaaaaa;"></div>
      <span>10 (Light)</span>
    </div>
    <div class="legend-item">
      <div class="legend-box" style="background: #ffffff;"></div>
      <span>11 (White)</span>
    </div>
  </div>

  <div class="data-display">
    <div>Data: <span id="dataText"></span></div>
    <div>Encoded bits: <span id="bitCount"></span></div>
  </div>

  <div class="note">
    4 levels = 2 bits per module. Standard QR finder patterns preserved in black/white.<br>
    Data modules use all 4 levels. Receiver must distinguish 4 brightness thresholds.
  </div>

  <script src="https://unpkg.com/qrcode-generator@1.4.4/qrcode.js"></script>
  <script>
    // Test data - we'll encode this as 4-level grayscale
    const TEST_DATA = 'GRAY4:TEST:DATA:1234567890:ABCDEFGHIJ';
    document.getElementById('dataText').textContent = TEST_DATA;

    // Gray levels for 2-bit encoding
    const LEVELS = [0, 85, 170, 255]; // 00, 01, 10, 11

    // Generate a standard QR to get the module pattern
    const qr = qrcode(0, 'M');
    qr.addData(TEST_DATA);
    qr.make();

    const moduleCount = qr.getModuleCount();
    const compositeSize = 400;
    const cellSize = compositeSize / moduleCount;

    const canvas = document.getElementById('compositeCanvas');
    const ctx = canvas.getContext('2d');

    // Convert test data to bits
    const bits = [];
    for (const char of TEST_DATA) {
      const code = char.charCodeAt(0);
      for (let i = 7; i >= 0; i--) {
        bits.push((code >> i) & 1);
      }
    }
    document.getElementById('bitCount').textContent = bits.length;

    // Group bits into pairs for 4-level encoding
    const pairs = [];
    for (let i = 0; i < bits.length; i += 2) {
      const b1 = bits[i] || 0;
      const b2 = bits[i + 1] || 0;
      pairs.push((b1 << 1) | b2); // 0-3
    }

    let pairIndex = 0;

    // Draw QR with 4-level encoding
    // Finder patterns, timing, alignment stay black/white
    // Data modules use 4 levels

    function isFinderPattern(row, col, size) {
      // Top-left finder
      if (row < 8 && col < 8) return true;
      // Top-right finder
      if (row < 8 && col >= size - 8) return true;
      // Bottom-left finder
      if (row >= size - 8 && col < 8) return true;
      return false;
    }

    function isTimingPattern(row, col) {
      return row === 6 || col === 6;
    }

    // Fill background white
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, compositeSize, compositeSize);

    for (let row = 0; row < moduleCount; row++) {
      for (let col = 0; col < moduleCount; col++) {
        const isDark = qr.isDark(row, col);
        const x = col * cellSize;
        const y = row * cellSize;

        // Finder patterns and timing stay binary for scanner to find QR
        if (isFinderPattern(row, col, moduleCount) || isTimingPattern(row, col)) {
          ctx.fillStyle = isDark ? '#000000' : '#ffffff';
        } else {
          // Data area: use 4 levels
          // Map original QR bit + extra bit from our data
          if (isDark) {
            // Original QR says dark - use level 0 or 1
            const extraBit = pairs[pairIndex % pairs.length] & 1;
            ctx.fillStyle = extraBit ? `rgb(85,85,85)` : `rgb(0,0,0)`;
            pairIndex++;
          } else {
            // Original QR says light - use level 2 or 3
            const extraBit = pairs[pairIndex % pairs.length] & 1;
            ctx.fillStyle = extraBit ? `rgb(255,255,255)` : `rgb(170,170,170)`;
            pairIndex++;
          }
        }

        ctx.fillRect(x, y, cellSize + 0.5, cellSize + 0.5);
      }
    }

    console.log('4-Level Grayscale QR Sender ready');
    console.log('Modules:', moduleCount * moduleCount);
    console.log('Data pairs used:', pairIndex);
  </script>
</body>
</html>
