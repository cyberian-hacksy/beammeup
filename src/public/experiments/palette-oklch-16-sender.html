<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Palette-OKLCH-16 Sender</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: system-ui, sans-serif;
      background: #1a1a2e;
      color: #e0e0e0;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
    }
    h1 { margin-bottom: 10px; color: #00d4ff; }
    .description {
      max-width: 600px;
      text-align: center;
      margin-bottom: 20px;
      color: #aaa;
      font-size: 0.9em;
    }
    .controls {
      margin-bottom: 15px;
    }
    .composite-section {
      text-align: center;
      margin: 20px 0;
    }
    .composite-section h2 {
      margin-bottom: 15px;
      color: #00d4ff;
    }
    #compositeCanvas {
      border: 3px solid #00d4ff;
      border-radius: 8px;
      image-rendering: pixelated;
    }
    .palette-section {
      margin: 20px 0;
      padding: 20px;
      background: #252540;
      border-radius: 8px;
      max-width: 700px;
    }
    .palette-section h3 {
      color: #00d4ff;
      margin-bottom: 15px;
      text-align: center;
      font-size: 14px;
    }
    .palette-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 8px;
    }
    .palette-entry {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 8px;
      background: #1a1a2e;
      border-radius: 6px;
      border: 1px solid #333;
    }
    .palette-swatch {
      width: 36px;
      height: 36px;
      border-radius: 4px;
      border: 2px solid #444;
      margin-bottom: 6px;
    }
    .palette-index {
      font-size: 14px;
      font-weight: bold;
      color: #00d4ff;
    }
    .palette-binary {
      font-size: 10px;
      color: #888;
      font-family: monospace;
      margin-top: 2px;
    }
    .palette-name {
      font-size: 10px;
      color: #888;
      margin-top: 2px;
    }
    .palette-rgb {
      font-size: 9px;
      color: #666;
      font-family: monospace;
      margin-top: 2px;
    }
    .data-display {
      margin-top: 15px;
      padding: 15px;
      background: #252540;
      border-radius: 8px;
      max-width: 500px;
      font-family: monospace;
      font-size: 11px;
    }
    .data-display div { margin: 4px 0; }
    .data-display .bit3 { color: #ff9999; }
    .data-display .bit2 { color: #ff6666; }
    .data-display .bit1 { color: #66ff66; }
    .data-display .bit0 { color: #6666ff; }
    .note {
      margin-top: 15px;
      padding: 10px;
      background: #252540;
      border-radius: 8px;
      font-size: 11px;
      color: #888;
      max-width: 600px;
      text-align: center;
    }
    .approach-comparison {
      margin-top: 15px;
      padding: 15px;
      background: #1a2a3a;
      border: 1px solid #00d4ff33;
      border-radius: 8px;
      max-width: 600px;
      font-size: 12px;
    }
    .approach-comparison h3 {
      color: #00d4ff;
      margin-bottom: 10px;
      font-size: 13px;
    }
    .approach-comparison ul {
      list-style: none;
      padding: 0;
    }
    .approach-comparison li {
      margin: 5px 0;
      padding-left: 15px;
      position: relative;
    }
    .approach-comparison li::before {
      content: "-";
      position: absolute;
      left: 0;
      color: #00d4ff;
    }
  </style>
</head>
<body>
  <h1>Palette-OKLCH-16 Sender</h1>
  <p class="description">
    <strong>16-Color Palette Encoding:</strong> Each QR module is assigned a color from a fixed 16-color palette.<br>
    Four data channels combine into a 4-bit index (0-15) that selects the palette color.<br>
    Receiver uses OKLCH color space for perceptually uniform nearest-neighbor classification.
  </p>

  <div id="controls" class="controls"></div>

  <div class="composite-section">
    <h2>Palette-OKLCH-16 QR Code</h2>
    <canvas id="compositeCanvas" width="440" height="440"></canvas>
  </div>

  <div class="palette-section">
    <h3>16-Color Palette (4-bit index = bit3*8 + bit2*4 + bit1*2 + bit0)</h3>
    <div class="palette-grid" id="paletteGrid"></div>
  </div>

  <div class="data-display">
    <div class="bit3">Bit 3 (MSB): <span id="dataBit3"></span></div>
    <div class="bit2">Bit 2: <span id="dataBit2"></span></div>
    <div class="bit1">Bit 1: <span id="dataBit1"></span></div>
    <div class="bit0">Bit 0 (LSB): <span id="dataBit0"></span></div>
  </div>

  <div class="approach-comparison">
    <h3>16-Color OKLCH Classification Approach</h3>
    <ul>
      <li><strong>Encoding:</strong> 4-bit index (0-15) selects color from fixed palette</li>
      <li><strong>Decoding:</strong> OKLCH nearest-neighbor finds closest palette color</li>
      <li>4 bits per module = 33% more data than 8-color (3-bit) palette</li>
      <li>More challenging classification with 16 distinct colors</li>
      <li>OKLCH handles perceptual uniformity for better discrimination</li>
    </ul>
  </div>

  <div class="note" id="noteDisplay">
    <strong>Layout:</strong> <span id="noteSize">440x440</span> square with <span id="noteMargin">10</span>px margin.<br>
    Finder patterns remain black/white for detection compatibility.
  </div>

  <script src="https://unpkg.com/qrcode-generator@1.4.4/qrcode.js"></script>
  <script type="module">
    import { createDisplaySizeSelector, displaySizeStyles } from './shared/display-size.js';

    // Inject display size selector styles
    const style = document.createElement('style');
    style.textContent = displaySizeStyles;
    document.head.appendChild(style);

    // Test data for each bit channel (4 QR codes for 4 bits)
    const DATA_BIT3 = 'BIT3:QR16:V1:12345';
    const DATA_BIT2 = 'BIT2:QR16:V1:67890';
    const DATA_BIT1 = 'BIT1:QR16:V1:ABCDE';
    const DATA_BIT0 = 'BIT0:QR16:V1:FGHIJ';

    document.getElementById('dataBit3').textContent = DATA_BIT3;
    document.getElementById('dataBit2').textContent = DATA_BIT2;
    document.getElementById('dataBit1').textContent = DATA_BIT1;
    document.getElementById('dataBit0').textContent = DATA_BIT0;

    // Fixed 16-color palette indexed by 4-bit value
    // Inverted for QR compatibility: dark modules (high index) produce dark colors
    // index 15 = black (all bits on), index 0 = white (all bits off)
    const PALETTE = [
      { index: 0,  name: 'White',      rgb: [255, 255, 255] },
      { index: 1,  name: 'Yellow',     rgb: [255, 255, 0] },
      { index: 2,  name: 'Magenta',    rgb: [255, 0, 255] },
      { index: 3,  name: 'Red',        rgb: [255, 0, 0] },
      { index: 4,  name: 'Cyan',       rgb: [0, 255, 255] },
      { index: 5,  name: 'Lime',       rgb: [0, 255, 0] },
      { index: 6,  name: 'Blue',       rgb: [0, 0, 255] },
      { index: 7,  name: 'Silver',     rgb: [192, 192, 192] },
      { index: 8,  name: 'Gray',       rgb: [128, 128, 128] },
      { index: 9,  name: 'Olive',      rgb: [128, 128, 0] },
      { index: 10, name: 'Purple',     rgb: [128, 0, 128] },
      { index: 11, name: 'Maroon',     rgb: [128, 0, 0] },
      { index: 12, name: 'Teal',       rgb: [0, 128, 128] },
      { index: 13, name: 'Dark Green', rgb: [0, 128, 0] },
      { index: 14, name: 'Navy',       rgb: [0, 0, 128] },
      { index: 15, name: 'Black',      rgb: [0, 0, 0] }
    ];

    // Palette lookup function
    function getPaletteColor(index) {
      return PALETTE[index].rgb;
    }

    // Convert index to 4-bit binary string
    function toBinary4(index) {
      return index.toString(2).padStart(4, '0');
    }

    // Generate palette display (4x4 grid)
    const paletteGrid = document.getElementById('paletteGrid');
    PALETTE.forEach((entry) => {
      const div = document.createElement('div');
      div.className = 'palette-entry';

      const swatch = document.createElement('div');
      swatch.className = 'palette-swatch';
      swatch.style.background = 'rgb(' + entry.rgb.join(',') + ')';

      const indexLabel = document.createElement('div');
      indexLabel.className = 'palette-index';
      indexLabel.textContent = entry.index;

      const binaryLabel = document.createElement('div');
      binaryLabel.className = 'palette-binary';
      binaryLabel.textContent = toBinary4(entry.index);

      const nameLabel = document.createElement('div');
      nameLabel.className = 'palette-name';
      nameLabel.textContent = entry.name;

      const rgbLabel = document.createElement('div');
      rgbLabel.className = 'palette-rgb';
      rgbLabel.textContent = '[' + entry.rgb.join(', ') + ']';

      div.appendChild(swatch);
      div.appendChild(indexLabel);
      div.appendChild(binaryLabel);
      div.appendChild(nameLabel);
      div.appendChild(rgbLabel);
      paletteGrid.appendChild(div);
    });

    // Generate QR modules
    function getQRModules(data) {
      const qr = qrcode(0, 'M');
      qr.addData(data);
      qr.make();
      const count = qr.getModuleCount();
      const modules = [];
      for (let r = 0; r < count; r++) {
        modules[r] = [];
        for (let c = 0; c < count; c++) {
          modules[r][c] = qr.isDark(r, c) ? 1 : 0;
        }
      }
      return { modules, count };
    }

    // Check if position is finder/timing pattern
    function isFinderOrTiming(row, col, size) {
      // Top-left finder (includes separator)
      if (row < 8 && col < 8) return true;
      // Top-right finder
      if (row < 8 && col >= size - 8) return true;
      // Bottom-left finder
      if (row >= size - 8 && col < 8) return true;
      // Timing patterns
      if (row === 6 || col === 6) return true;
      // Alignment pattern for larger QR codes
      if (size > 25) {
        const alignPos = size - 7;
        if (row >= alignPos - 2 && row <= alignPos + 2 &&
            col >= alignPos - 2 && col <= alignPos + 2) return true;
      }
      return false;
    }

    // Pre-generate QR modules for each bit channel (4 QR codes)
    const qrBit3 = getQRModules(DATA_BIT3);
    const qrBit2 = getQRModules(DATA_BIT2);
    const qrBit1 = getQRModules(DATA_BIT1);
    const qrBit0 = getQRModules(DATA_BIT0);
    const moduleCount = qrBit3.count;

    const canvas = document.getElementById('compositeCanvas');
    const ctx = canvas.getContext('2d');
    const noteSizeEl = document.getElementById('noteSize');
    const noteMarginEl = document.getElementById('noteMargin');

    // Fixed margin around QR code
    const MARGIN = 10;

    // Render QR code at specified canvas size using palette lookup
    function renderQR(canvasSize) {
      // QR fills canvas minus margin on each side
      const qrSize = canvasSize - MARGIN * 2;

      // Update canvas dimensions
      canvas.width = canvasSize;
      canvas.height = canvasSize;

      // Fill with white background (required for QR quiet zone)
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(0, 0, canvasSize, canvasSize);

      // Draw QR code centered with margin
      const cellSize = qrSize / moduleCount;
      const qrOffsetX = MARGIN;
      const qrOffsetY = MARGIN;

      for (let row = 0; row < moduleCount; row++) {
        for (let col = 0; col < moduleCount; col++) {
          // Get bit values from each channel's QR code
          // Dark module (1) = bit ON, Light module (0) = bit OFF
          const bit3 = qrBit3.modules[row][col];  // bit 3 (MSB)
          const bit2 = qrBit2.modules[row][col];  // bit 2
          const bit1 = qrBit1.modules[row][col];  // bit 1
          const bit0 = qrBit0.modules[row][col];  // bit 0 (LSB)

          let color;
          if (isFinderOrTiming(row, col, moduleCount)) {
            // Keep finder patterns black/white for detection
            color = bit3 ? [0, 0, 0] : [255, 255, 255];
          } else {
            // Palette lookup: combine bits into 4-bit index, then lookup color
            const paletteIndex = bit3 * 8 + bit2 * 4 + bit1 * 2 + bit0;
            color = getPaletteColor(paletteIndex);
          }

          const x = qrOffsetX + col * cellSize;
          const yPos = qrOffsetY + row * cellSize;

          ctx.fillStyle = 'rgb(' + color.join(',') + ')';
          ctx.fillRect(x, yPos, cellSize + 0.5, cellSize + 0.5);
        }
      }

      // Update note display
      noteSizeEl.textContent = canvasSize + 'x' + canvasSize;
      noteMarginEl.textContent = MARGIN;

      console.log('Palette-OKLCH-16 Sender rendered at', canvasSize + 'x' + canvasSize);
      console.log('Module count:', moduleCount);
      console.log('Margin:', MARGIN, 'px');
      console.log('Approach: 16-color palette with OKLCH classification on receiver');
    }

    // Create size selector
    const getSize = createDisplaySizeSelector(
      document.getElementById('controls'),
      (newSize) => renderQR(newSize),
      440 // default size
    );

    // Initial render
    renderQR(440);

    console.log('Palette-OKLCH-16 Sender ready');
    console.log('Palette colors:', PALETTE.map(p => p.name).join(', '));
    console.log('Decoding approach: OKLCH nearest-neighbor classification (16 colors)');
    console.log('Bits per module: 4 (compared to 3 for 8-color palette)');
  </script>
</body>
</html>
