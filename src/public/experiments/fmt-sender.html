<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>FMT Sender</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: system-ui, sans-serif;
      background: #1a1a2e;
      color: #e0e0e0;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
    }
    h1 { margin-bottom: 10px; color: #00d4ff; }
    .description {
      max-width: 600px;
      text-align: center;
      margin-bottom: 20px;
      color: #aaa;
      font-size: 0.9em;
    }
    .controls {
      margin-bottom: 15px;
    }
    .composite-section {
      text-align: center;
      margin: 20px 0;
    }
    .composite-section h2 {
      margin-bottom: 15px;
      color: #00d4ff;
    }
    #compositeCanvas {
      border: 3px solid #00d4ff;
      border-radius: 8px;
      image-rendering: pixelated;
    }
    .legend {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      justify-content: center;
      margin: 20px 0;
      max-width: 600px;
    }
    .legend-item {
      display: flex;
      align-items: center;
      gap: 5px;
      font-size: 10px;
      padding: 4px 8px;
      background: #252540;
      border-radius: 4px;
    }
    .legend-box {
      width: 20px;
      height: 20px;
      border-radius: 3px;
      border: 1px solid #444;
    }
    .data-display {
      margin-top: 15px;
      padding: 15px;
      background: #252540;
      border-radius: 8px;
      max-width: 500px;
      font-family: monospace;
      font-size: 11px;
    }
    .data-display div { margin: 4px 0; }
    .data-display .red { color: #ff6666; }
    .data-display .green { color: #66ff66; }
    .data-display .blue { color: #6666ff; }
    .note {
      margin-top: 15px;
      padding: 10px;
      background: #252540;
      border-radius: 8px;
      font-size: 11px;
      color: #888;
      max-width: 600px;
      text-align: center;
    }
    .approach-comparison {
      margin-top: 15px;
      padding: 15px;
      background: #1a2a3a;
      border: 1px solid #00d4ff33;
      border-radius: 8px;
      max-width: 600px;
      font-size: 12px;
    }
    .approach-comparison h3 {
      color: #00d4ff;
      margin-bottom: 10px;
      font-size: 13px;
    }
    .approach-comparison ul {
      list-style: none;
      padding: 0;
    }
    .approach-comparison li {
      margin: 5px 0;
      padding-left: 15px;
      position: relative;
    }
    .approach-comparison li::before {
      content: "-";
      position: absolute;
      left: 0;
      color: #00d4ff;
    }
    .shade-selector {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 10px;
      padding: 10px 15px;
      background: #252540;
      border-radius: 8px;
    }
    .shade-selector label {
      font-size: 12px;
      color: #aaa;
    }
    .shade-selector .shade-options {
      display: flex;
      gap: 5px;
    }
    .shade-selector button {
      padding: 6px 12px;
      border: 1px solid #444;
      background: #1a1a2e;
      color: #e0e0e0;
      border-radius: 4px;
      cursor: pointer;
      font-size: 11px;
    }
    .shade-selector button.active {
      background: #00d4ff;
      color: #1a1a2e;
      border-color: #00d4ff;
      font-weight: bold;
    }
    .shade-selector button:hover:not(.active) {
      background: #333;
    }
    .mode-info {
      margin-top: 10px;
      padding: 10px;
      background: #1a2a3a;
      border: 1px solid #00d4ff33;
      border-radius: 8px;
      font-size: 11px;
      text-align: center;
    }
    .mode-info .highlight {
      color: #00d4ff;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <h1>FMT Sender</h1>
  <p class="description" id="descriptionText">
    <strong>Format Mathematical Transform:</strong> Direct mathematical mapping from N-bit values to RGB colors.<br>
    Scalable shades per channel: 2 shades = 8 colors (3 bits), 4 shades = 64 colors (6 bits).
  </p>

  <div id="controls" class="controls"></div>

  <div class="composite-section">
    <h2>FMT Color QR Code</h2>
    <canvas id="compositeCanvas" width="440" height="440"></canvas>
  </div>

  <div class="legend" id="legend"></div>

  <div class="data-display">
    <div class="red">Red channel (bit 2): <span id="dataRed"></span></div>
    <div class="green">Green channel (bit 1): <span id="dataGreen"></span></div>
    <div class="blue">Blue channel (bit 0): <span id="dataBlue"></span></div>
  </div>

  <div class="approach-comparison">
    <h3>FMT Scalability</h3>
    <ul>
      <li><strong>2 shades:</strong> 8 colors, 3 bits/module — same as QRGB baseline</li>
      <li><strong>4 shades:</strong> 64 colors, 6 bits/module — 2x capacity per module</li>
      <li>Formula: RGB values evenly spaced (0, 85, 170, 255 for 4 shades)</li>
      <li>Finder patterns remain B/W for detection compatibility</li>
    </ul>
  </div>
  <div class="mode-info" id="modeInfo">
    Current mode: <span class="highlight">2 shades (8 colors, 3 bits/module)</span>
  </div>

  <div class="note" id="noteDisplay">
    <strong>Layout:</strong> <span id="noteSize">440x440</span> square with <span id="noteMargin">10</span>px margin.<br>
    Finder patterns remain black/white for detection compatibility.
  </div>

  <script src="https://unpkg.com/qrcode-generator@1.4.4/qrcode.js"></script>
  <script type="module">
    import { createDisplaySizeSelector, displaySizeStyles } from './shared/display-size.js';

    // Inject display size selector styles
    const style = document.createElement('style');
    style.textContent = displaySizeStyles;
    document.head.appendChild(style);

    // Test data for each channel
    const DATA_RED = 'RED:FMT:V1:12345';
    const DATA_GREEN = 'GREEN:FMT:V1:67890';
    const DATA_BLUE = 'BLUE:FMT:V1:ABCDE';

    document.getElementById('dataRed').textContent = DATA_RED;
    document.getElementById('dataGreen').textContent = DATA_GREEN;
    document.getElementById('dataBlue').textContent = DATA_BLUE;

    // Current shade setting
    let currentShades = 2;
    let currentCanvasSize = 440;

    // FMT Mathematical Transform: N-bit value to RGB color
    // Scalable to any number of shades per channel
    function fmtEncode(value, shadesPerChannel = 2) {
      const maxShade = shadesPerChannel - 1;
      const step = maxShade > 0 ? 255 / maxShade : 255;

      const r = Math.floor(value / (shadesPerChannel * shadesPerChannel)) % shadesPerChannel;
      const g = Math.floor(value / shadesPerChannel) % shadesPerChannel;
      const b = value % shadesPerChannel;

      // Invert for QR compatibility (high shade index = dark)
      return [
        Math.round((maxShade - r) * step),
        Math.round((maxShade - g) * step),
        Math.round((maxShade - b) * step)
      ];
    }

    // Generate all colors for current shade count
    function generateColorPalette(shadesPerChannel) {
      const totalColors = shadesPerChannel ** 3;
      const colors = [];
      for (let i = 0; i < totalColors; i++) {
        const bits = i.toString(2).padStart(Math.log2(totalColors), '0');
        colors.push({
          value: i,
          binary: bits,
          label: i.toString(),
          color: fmtEncode(i, shadesPerChannel)
        });
      }
      return colors;
    }

    // Update legend for current shade count
    function updateLegend(shadesPerChannel) {
      const legendEl = document.getElementById('legend');
      // Clear legend using safe DOM method
      while (legendEl.firstChild) {
        legendEl.removeChild(legendEl.firstChild);
      }

      const colors = generateColorPalette(shadesPerChannel);
      const totalColors = colors.length;

      // For 64 colors, show a subset (corners of the color cube)
      const colorsToShow = totalColors <= 8 ? colors : [
        colors[0],   // 0: White
        colors[7],   // 7
        colors[56],  // 56
        colors[63],  // 63: Black
        colors[21],  // sample mid-colors
        colors[42],
        colors[9],
        colors[54]
      ];

      colorsToShow.forEach((c) => {
        const item = document.createElement('div');
        item.className = 'legend-item';

        const box = document.createElement('div');
        box.className = 'legend-box';
        box.style.background = 'rgb(' + c.color.join(',') + ')';

        const label = document.createElement('span');
        label.textContent = totalColors <= 8 ? c.label : c.value + ' [' + c.color.join(',') + ']';

        item.appendChild(box);
        item.appendChild(label);
        legendEl.appendChild(item);
      });

      if (totalColors > 8) {
        const note = document.createElement('div');
        note.className = 'legend-item';
        note.style.fontStyle = 'italic';
        note.style.color = '#888';
        note.textContent = '(' + totalColors + ' colors total, showing sample)';
        legendEl.appendChild(note);
      }
    }

    // Generate QR modules
    function getQRModules(data) {
      const qr = qrcode(0, 'M');
      qr.addData(data);
      qr.make();
      const count = qr.getModuleCount();
      const modules = [];
      for (let r = 0; r < count; r++) {
        modules[r] = [];
        for (let c = 0; c < count; c++) {
          modules[r][c] = qr.isDark(r, c) ? 1 : 0;
        }
      }
      return { modules, count };
    }

    // Check if position is finder/timing pattern
    function isFinderOrTiming(row, col, size) {
      if (row < 8 && col < 8) return true;
      if (row < 8 && col >= size - 8) return true;
      if (row >= size - 8 && col < 8) return true;
      if (row === 6 || col === 6) return true;
      if (size > 25) {
        const alignPos = size - 7;
        if (row >= alignPos - 2 && row <= alignPos + 2 &&
            col >= alignPos - 2 && col <= alignPos + 2) return true;
      }
      return false;
    }

    // Pre-generate QR modules for each channel
    const qrRed = getQRModules(DATA_RED);
    const qrGreen = getQRModules(DATA_GREEN);
    const qrBlue = getQRModules(DATA_BLUE);
    const moduleCount = qrRed.count;

    const canvas = document.getElementById('compositeCanvas');
    const ctx = canvas.getContext('2d');
    const noteSizeEl = document.getElementById('noteSize');
    const noteMarginEl = document.getElementById('noteMargin');
    const modeInfoEl = document.getElementById('modeInfo');

    const MARGIN = 10;

    // Update mode info display safely
    function updateModeInfo(shadesPerChannel) {
      const totalColors = shadesPerChannel ** 3;
      const bitsPerModule = Math.log2(totalColors);

      // Clear and rebuild safely
      while (modeInfoEl.firstChild) {
        modeInfoEl.removeChild(modeInfoEl.firstChild);
      }

      modeInfoEl.appendChild(document.createTextNode('Current mode: '));
      const highlight = document.createElement('span');
      highlight.className = 'highlight';
      highlight.textContent = shadesPerChannel + ' shades (' + totalColors + ' colors, ' +
        bitsPerModule + ' bits/module)';
      modeInfoEl.appendChild(highlight);
    }

    // Render QR code with current shade setting
    function renderQR(canvasSize, shadesPerChannel = currentShades) {
      currentCanvasSize = canvasSize;
      const qrSize = canvasSize - MARGIN * 2;

      canvas.width = canvasSize;
      canvas.height = canvasSize;

      ctx.fillStyle = '#ffffff';
      ctx.fillRect(0, 0, canvasSize, canvasSize);

      const cellSize = qrSize / moduleCount;
      const qrOffsetX = MARGIN;
      const qrOffsetY = MARGIN;

      for (let row = 0; row < moduleCount; row++) {
        for (let col = 0; col < moduleCount; col++) {
          const rBit = qrRed.modules[row][col];
          const gBit = qrGreen.modules[row][col];
          const bBit = qrBlue.modules[row][col];

          let color;
          if (isFinderOrTiming(row, col, moduleCount)) {
            // Keep finder patterns black/white for detection
            color = rBit ? [0, 0, 0] : [255, 255, 255];
          } else {
            if (shadesPerChannel === 2) {
              // 2 shades: standard FMT (same as QRGB)
              const value = rBit * 4 + gBit * 2 + bBit;
              color = fmtEncode(value, 2);
            } else {
              // 4 shades: use 2 bits per channel
              // Map binary QR values to shade levels: 0→0, 1→3 (extremes)
              // For intermediate values, we use position-based pattern
              const rShade = rBit * 3;  // 0 or 3
              const gShade = gBit * 3;  // 0 or 3
              const bShade = bBit * 3;  // 0 or 3

              // Add intermediate shades based on module position for variety
              const posHash = (row * 7 + col * 13) % 4;
              const rFinal = rBit ? Math.min(3, rShade) : Math.max(0, posHash % 2);
              const gFinal = gBit ? Math.min(3, gShade) : Math.max(0, (posHash >> 1) % 2);
              const bFinal = bBit ? Math.min(3, bShade) : Math.max(0, posHash % 2);

              const value = rFinal * 16 + gFinal * 4 + bFinal;
              color = fmtEncode(value, 4);
            }
          }

          const x = qrOffsetX + col * cellSize;
          const yPos = qrOffsetY + row * cellSize;

          ctx.fillStyle = 'rgb(' + color.join(',') + ')';
          ctx.fillRect(x, yPos, cellSize + 0.5, cellSize + 0.5);
        }
      }

      noteSizeEl.textContent = canvasSize + 'x' + canvasSize;
      noteMarginEl.textContent = MARGIN;
      updateModeInfo(shadesPerChannel);

      console.log('FMT Sender rendered:', shadesPerChannel, 'shades,', shadesPerChannel ** 3, 'colors');
    }

    // Create shade selector
    function createShadeSelector() {
      const controlsEl = document.getElementById('controls');

      const container = document.createElement('div');
      container.className = 'shade-selector';

      const label = document.createElement('label');
      label.textContent = 'Shades per channel:';
      container.appendChild(label);

      const options = document.createElement('div');
      options.className = 'shade-options';

      [2, 4].forEach(shades => {
        const btn = document.createElement('button');
        const colors = shades ** 3;
        btn.textContent = shades + ' (' + colors + ' colors)';
        btn.dataset.shades = shades;
        if (shades === currentShades) btn.classList.add('active');

        btn.addEventListener('click', () => {
          currentShades = shades;
          options.querySelectorAll('button').forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
          updateLegend(shades);
          renderQR(currentCanvasSize, shades);
        });

        options.appendChild(btn);
      });

      container.appendChild(options);
      controlsEl.insertBefore(container, controlsEl.firstChild);
    }

    // Create size selector
    createShadeSelector();
    createDisplaySizeSelector(
      document.getElementById('controls'),
      (newSize) => renderQR(newSize, currentShades),
      440
    );

    // Initial render
    updateLegend(currentShades);
    renderQR(440, currentShades);

    console.log('FMT Sender ready - scalable shades support');
  </script>
</body>
</html>
