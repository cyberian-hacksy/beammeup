<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>PCCC Color QR Receiver v3</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: system-ui, sans-serif;
      background: #1a1a2e;
      color: #e0e0e0;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 10px;
    }
    h1 { margin-bottom: 5px; color: #00d4ff; font-size: 1.4em; }
    .description {
      text-align: center;
      margin-bottom: 10px;
      color: #aaa;
      font-size: 0.85em;
    }
    #video {
      width: 100%;
      max-width: 400px;
      border: 2px solid #333;
      border-radius: 8px;
    }
    #captureCanvas { display: none; }
    .controls {
      display: flex;
      gap: 10px;
      margin: 10px 0;
      flex-wrap: wrap;
      justify-content: center;
    }
    button {
      padding: 10px 20px;
      background: #00d4ff;
      color: #1a1a2e;
      border: none;
      border-radius: 4px;
      font-weight: bold;
      cursor: pointer;
    }
    button:disabled { background: #333; color: #666; }
    .calibration-status {
      width: 100%;
      max-width: 400px;
      padding: 10px;
      background: #252540;
      border-radius: 8px;
      margin: 10px 0;
      font-size: 11px;
    }
    .calibration-status h3 {
      color: #00d4ff;
      font-size: 12px;
      margin-bottom: 8px;
    }
    .corner-patches {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 5px;
    }
    .corner-patch {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 5px;
      background: #1a1a2e;
      border-radius: 4px;
    }
    .corner-patch .color-box {
      width: 30px;
      height: 30px;
      border-radius: 4px;
      border: 1px solid #444;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
      font-weight: bold;
    }
    .corner-patch .info {
      font-size: 9px;
    }
    .corner-patch .info .label { color: #888; }
    .corner-patch .info .values { color: #fff; font-family: monospace; }
    .status-text {
      text-align: center;
      margin-top: 8px;
      padding: 5px;
      background: #1a1a2e;
      border-radius: 4px;
    }
    .status-text.good { color: #6bff6b; }
    .status-text.bad { color: #ff6b6b; }
    .status-text.detecting { color: #ffff6b; }
    .channels {
      display: flex;
      gap: 8px;
      margin: 10px 0;
      flex-wrap: wrap;
      justify-content: center;
    }
    .channel { text-align: center; }
    .channel canvas {
      border: 2px solid #333;
      border-radius: 4px;
      width: 110px;
      height: 110px;
    }
    .channel p { margin-top: 4px; font-size: 10px; }
    .channel.cyan p { color: #00ffff; }
    .channel.magenta p { color: #ff00ff; }
    .channel.yellow p { color: #ffff00; }
    .results {
      width: 100%;
      max-width: 400px;
      padding: 10px;
      background: #252540;
      border-radius: 8px;
      font-size: 11px;
    }
    .result {
      margin: 5px 0;
      padding: 6px;
      border-radius: 4px;
      background: #1a1a2e;
    }
    .result.success { border-left: 3px solid #6bff6b; }
    .result.failure { border-left: 3px solid #ff6b6b; }
    .result .label { font-weight: bold; margin-bottom: 3px; }
    .result.cyan .label { color: #00ffff; }
    .result.magenta .label { color: #ff00ff; }
    .result.yellow .label { color: #ffff00; }
    .result .data { word-break: break-all; color: #fff; font-size: 10px; }
    .stats-bar {
      margin-top: 10px;
      padding: 8px;
      background: #1a1a2e;
      border-radius: 4px;
      text-align: center;
      font-size: 11px;
    }
    .debug-info {
      margin-top: 10px;
      padding: 8px;
      background: #1a1a2e;
      border-radius: 4px;
      font-size: 9px;
      color: #666;
      font-family: monospace;
    }
  </style>
</head>
<body>
  <h1>PCCC Receiver v3</h1>
  <p class="description">QR-first detection with corner calibration and matrix correction</p>

  <div class="controls">
    <button id="startBtn">Start Camera</button>
  </div>

  <video id="video" autoplay playsinline></video>
  <canvas id="captureCanvas"></canvas>

  <div class="calibration-status">
    <h3>Corner Calibration (from QR boundary)</h3>
    <div class="corner-patches">
      <div class="corner-patch" id="cornerTL">
        <div class="color-box" style="background:#333">W</div>
        <div class="info">
          <div class="label">Top-Left (White)</div>
          <div class="values">---</div>
        </div>
      </div>
      <div class="corner-patch" id="cornerTR">
        <div class="color-box" style="background:#333">C</div>
        <div class="info">
          <div class="label">Top-Right (Cyan)</div>
          <div class="values">---</div>
        </div>
      </div>
      <div class="corner-patch" id="cornerBL">
        <div class="color-box" style="background:#333">M</div>
        <div class="info">
          <div class="label">Bottom-Left (Magenta)</div>
          <div class="values">---</div>
        </div>
      </div>
      <div class="corner-patch" id="cornerBR">
        <div class="color-box" style="background:#333">Y</div>
        <div class="info">
          <div class="label">Bottom-Right (Yellow)</div>
          <div class="values">---</div>
        </div>
      </div>
    </div>
    <div class="status-text detecting" id="calibStatus">Looking for QR code...</div>
    <div class="debug-info" id="debugInfo">QR: not found</div>
  </div>

  <div class="channels">
    <div class="channel cyan">
      <canvas id="cyanChannel" width="110" height="110"></canvas>
      <p>Cyan</p>
    </div>
    <div class="channel magenta">
      <canvas id="magentaChannel" width="110" height="110"></canvas>
      <p>Magenta</p>
    </div>
    <div class="channel yellow">
      <canvas id="yellowChannel" width="110" height="110"></canvas>
      <p>Yellow</p>
    </div>
  </div>

  <div class="results">
    <div class="result cyan">
      <div class="label">Cyan Channel:</div>
      <div id="cyanResult" class="data">-</div>
    </div>
    <div class="result magenta">
      <div class="label">Magenta Channel:</div>
      <div id="magentaResult" class="data">-</div>
    </div>
    <div class="result yellow">
      <div class="label">Yellow Channel:</div>
      <div id="yellowResult" class="data">-</div>
    </div>
    <div class="stats-bar">
      Scans: <span id="scanCount">0</span> |
      Success: <span id="successRate">0/0/0</span>
    </div>
  </div>

  <script src="https://unpkg.com/jsqr@1.4.0/dist/jsQR.js"></script>
  <script>
    const video = document.getElementById('video');
    const captureCanvas = document.getElementById('captureCanvas');
    const captureCtx = captureCanvas.getContext('2d', { willReadFrequently: true });
    const startBtn = document.getElementById('startBtn');

    const cyanCanvas = document.getElementById('cyanChannel');
    const magentaCanvas = document.getElementById('magentaChannel');
    const yellowCanvas = document.getElementById('yellowChannel');
    const cyanCtx = cyanCanvas.getContext('2d');
    const magentaCtx = magentaCanvas.getContext('2d');
    const yellowCtx = yellowCanvas.getContext('2d');

    let scanning = false;
    let scanCount = 0;
    let successCounts = { cyan: 0, magenta: 0, yellow: 0 };

    // Calibration data from corner patches
    // corners[0] = White (TL), corners[1] = Cyan (TR), corners[2] = Magenta (BL), corners[3] = Yellow (BR)
    let corners = [null, null, null, null];

    // All 8 CMY color combinations - we'll interpolate these from calibration
    const CMY_COLORS = [
      [0, 0, 0], // White
      [1, 0, 0], // Cyan
      [0, 1, 0], // Magenta
      [0, 0, 1], // Yellow
      [1, 1, 0], // Blue (C+M)
      [1, 0, 1], // Green (C+Y)
      [0, 1, 1], // Red (M+Y)
      [1, 1, 1]  // Black (C+M+Y)
    ];

    startBtn.addEventListener('click', async () => {
      try {
        video.srcObject = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: 'environment', width: { ideal: 720 }, height: { ideal: 720 } }
        });
        video.play();
        startBtn.disabled = true;
        startBtn.textContent = 'Scanning...';
        scanning = true;
        requestAnimationFrame(scanFrame);
      } catch (err) {
        alert('Camera error: ' + err.message);
      }
    });

    // Sample average RGB from a region
    function sampleRegion(imageData, x, y, w, h) {
      const pixels = imageData.data;
      const width = imageData.width;
      let rSum = 0, gSum = 0, bSum = 0, count = 0;

      // Sample center portion
      const marginX = Math.floor(w * 0.25);
      const marginY = Math.floor(h * 0.25);
      const startX = Math.max(0, Math.floor(x) + marginX);
      const startY = Math.max(0, Math.floor(y) + marginY);
      const endX = Math.min(width, Math.floor(x + w) - marginX);
      const endY = Math.min(imageData.height, Math.floor(y + h) - marginY);

      for (let py = startY; py < endY; py++) {
        for (let px = startX; px < endX; px++) {
          const idx = (py * width + px) * 4;
          rSum += pixels[idx];
          gSum += pixels[idx + 1];
          bSum += pixels[idx + 2];
          count++;
        }
      }

      if (count === 0) return null;
      return [
        Math.round(rSum / count),
        Math.round(gSum / count),
        Math.round(bSum / count)
      ];
    }

    // Build expected RGB for each CMY combination using linear interpolation from calibration
    function buildExpectedColors() {
      if (!corners[0] || !corners[1] || !corners[2] || !corners[3]) return null;

      const W = corners[0]; // White (000)
      const C = corners[1]; // Cyan (100)
      const M = corners[2]; // Magenta (010)
      const Y = corners[3]; // Yellow (001)

      // Estimate what each CMY combination looks like
      // Using linear model: RGB(c,m,y) = W + c*(C-W) + m*(M-W) + y*(Y-W)
      // This assumes additive interference

      const expected = [];
      for (const cmy of CMY_COLORS) {
        const c = cmy[0], m = cmy[1], y = cmy[2];
        const r = W[0] + c * (C[0] - W[0]) + m * (M[0] - W[0]) + y * (Y[0] - W[0]);
        const g = W[1] + c * (C[1] - W[1]) + m * (M[1] - W[1]) + y * (Y[1] - W[1]);
        const b = W[2] + c * (C[2] - W[2]) + m * (M[2] - W[2]) + y * (Y[2] - W[2]);
        expected.push([
          Math.max(0, Math.min(255, Math.round(r))),
          Math.max(0, Math.min(255, Math.round(g))),
          Math.max(0, Math.min(255, Math.round(b)))
        ]);
      }

      return expected;
    }

    // Classify color using nearest neighbor to expected colors
    function classifyColor(r, g, b, expectedColors) {
      let minDist = Infinity;
      let bestIdx = 0;

      for (let i = 0; i < 8; i++) {
        const e = expectedColors[i];
        const dist = (r - e[0]) ** 2 + (g - e[1]) ** 2 + (b - e[2]) ** 2;
        if (dist < minDist) {
          minDist = dist;
          bestIdx = i;
        }
      }

      return CMY_COLORS[bestIdx];
    }

    // Convert image to grayscale for QR detection
    function toGrayscale(imageData) {
      const gray = new Uint8ClampedArray(imageData.width * imageData.height * 4);
      const pixels = imageData.data;

      for (let i = 0; i < pixels.length; i += 4) {
        const g = Math.round(pixels[i] * 0.299 + pixels[i + 1] * 0.587 + pixels[i + 2] * 0.114);
        gray[i] = g;
        gray[i + 1] = g;
        gray[i + 2] = g;
        gray[i + 3] = 255;
      }

      return gray;
    }

    // Update corner patch display
    function updateCornerDisplay(id, rgb) {
      const el = document.getElementById(id);
      const box = el.querySelector('.color-box');
      const values = el.querySelector('.values');

      if (rgb) {
        box.style.background = 'rgb(' + rgb.join(',') + ')';
        box.style.color = (rgb[0] + rgb[1] + rgb[2]) > 380 ? '#000' : '#fff';
        values.textContent = rgb.join(', ');
      }
    }

    function scanFrame() {
      if (!scanning) return;

      if (video.readyState === video.HAVE_ENOUGH_DATA) {
        const vw = video.videoWidth;
        const vh = video.videoHeight;
        const size = Math.min(vw, vh);

        captureCanvas.width = size;
        captureCanvas.height = size;

        const offsetX = (vw - size) / 2;
        const offsetY = (vh - size) / 2;
        captureCtx.drawImage(video, offsetX, offsetY, size, size, 0, 0, size, size);

        const imageData = captureCtx.getImageData(0, 0, size, size);
        const pixels = imageData.data;

        // Step 1: Convert to grayscale and try to find QR code
        const grayData = toGrayscale(imageData);
        const qrDetect = jsQR(grayData, size, size);

        const debugInfo = document.getElementById('debugInfo');
        const calibStatus = document.getElementById('calibStatus');

        if (!qrDetect) {
          debugInfo.textContent = 'QR: not found';
          calibStatus.textContent = 'Looking for QR code...';
          calibStatus.className = 'status-text detecting';
          requestAnimationFrame(scanFrame);
          return;
        }

        // Step 2: QR found! Calculate the bounding box
        const loc = qrDetect.location;
        const topLeft = loc.topLeftCorner;
        const topRight = loc.topRightCorner;
        const bottomLeft = loc.bottomLeftCorner;
        const bottomRight = loc.bottomRightCorner;

        // Calculate QR code bounds
        const qrLeft = Math.min(topLeft.x, bottomLeft.x);
        const qrRight = Math.max(topRight.x, bottomRight.x);
        const qrTop = Math.min(topLeft.y, topRight.y);
        const qrBottom = Math.max(bottomLeft.y, bottomRight.y);
        const qrWidth = qrRight - qrLeft;
        const qrHeight = qrBottom - qrTop;

        debugInfo.textContent = 'QR: ' + Math.round(qrLeft) + ',' + Math.round(qrTop) +
          ' size: ' + Math.round(qrWidth) + 'x' + Math.round(qrHeight);

        // Step 3: Calculate corner patch positions
        // Sender layout: 440x440 total, 20px corners, 400px QR in center
        // Corner ratio: 20/440 = ~4.5% of total, or 20/400 = 5% of QR size
        const patchRatio = 0.05; // Corner patch is ~5% of QR size
        const patchSize = qrWidth * patchRatio;

        // Corner positions (outside QR bounds)
        const cornerPositions = [
          { x: qrLeft - patchSize, y: qrTop - patchSize, id: 'cornerTL' },     // White
          { x: qrRight, y: qrTop - patchSize, id: 'cornerTR' },                 // Cyan
          { x: qrLeft - patchSize, y: qrBottom, id: 'cornerBL' },               // Magenta
          { x: qrRight, y: qrBottom, id: 'cornerBR' }                           // Yellow
        ];

        // Step 4: Sample corner patches
        let allCornersValid = true;
        for (let i = 0; i < 4; i++) {
          const pos = cornerPositions[i];
          // Check if patch is within image bounds
          if (pos.x < 0 || pos.y < 0 || pos.x + patchSize > size || pos.y + patchSize > size) {
            allCornersValid = false;
            corners[i] = null;
          } else {
            corners[i] = sampleRegion(imageData, pos.x, pos.y, patchSize, patchSize);
            if (!corners[i]) allCornersValid = false;
          }
          updateCornerDisplay(pos.id, corners[i]);
        }

        if (!allCornersValid) {
          calibStatus.textContent = 'QR found but corners not visible - zoom out';
          calibStatus.className = 'status-text bad';
          requestAnimationFrame(scanFrame);
          return;
        }

        // Step 5: Validate calibration (basic sanity checks)
        const wLum = corners[0][0] + corners[0][1] + corners[0][2];
        const cLum = corners[1][0] + corners[1][1] + corners[1][2];
        const mLum = corners[2][0] + corners[2][1] + corners[2][2];
        const yLum = corners[3][0] + corners[3][1] + corners[3][2];

        // White should be brightest
        if (wLum < Math.max(cLum, mLum, yLum)) {
          calibStatus.textContent = 'Calibration issue: white not brightest';
          calibStatus.className = 'status-text bad';
        } else {
          calibStatus.textContent = 'Calibration OK - processing...';
          calibStatus.className = 'status-text good';
        }

        // Step 6: Build expected colors from calibration
        const expectedColors = buildExpectedColors();
        if (!expectedColors) {
          requestAnimationFrame(scanFrame);
          return;
        }

        // Step 7: Process pixels using calibrated nearest-neighbor
        const cyanData = new Uint8ClampedArray(size * size * 4);
        const magentaData = new Uint8ClampedArray(size * size * 4);
        const yellowData = new Uint8ClampedArray(size * size * 4);

        for (let py = 0; py < size; py++) {
          for (let px = 0; px < size; px++) {
            const idx = (py * size + px) * 4;
            const r = pixels[idx];
            const g = pixels[idx + 1];
            const b = pixels[idx + 2];

            // Only process pixels inside the QR area
            let cmy;
            if (px >= qrLeft && px < qrRight && py >= qrTop && py < qrBottom) {
              cmy = classifyColor(r, g, b, expectedColors);
            } else {
              // Outside QR - treat as white (no ink)
              cmy = [0, 0, 0];
            }

            // Create binary channel images
            const cGray = cmy[0] ? 0 : 255;
            const mGray = cmy[1] ? 0 : 255;
            const yGray = cmy[2] ? 0 : 255;

            cyanData[idx] = cGray;
            cyanData[idx + 1] = cGray;
            cyanData[idx + 2] = cGray;
            cyanData[idx + 3] = 255;

            magentaData[idx] = mGray;
            magentaData[idx + 1] = mGray;
            magentaData[idx + 2] = mGray;
            magentaData[idx + 3] = 255;

            yellowData[idx] = yGray;
            yellowData[idx + 1] = yGray;
            yellowData[idx + 2] = yGray;
            yellowData[idx + 3] = 255;
          }
        }

        // Step 8: Draw channel previews
        drawPreview(cyanData, size, cyanCtx, 110);
        drawPreview(magentaData, size, magentaCtx, 110);
        drawPreview(yellowData, size, yellowCtx, 110);

        // Step 9: Try to decode each channel
        const cyanCode = jsQR(cyanData, size, size);
        const magentaCode = jsQR(magentaData, size, size);
        const yellowCode = jsQR(yellowData, size, size);

        scanCount++;
        updateResult('cyanResult', cyanCode, 'cyan');
        updateResult('magentaResult', magentaCode, 'magenta');
        updateResult('yellowResult', yellowCode, 'yellow');

        document.getElementById('scanCount').textContent = scanCount;
        document.getElementById('successRate').textContent =
          successCounts.cyan + '/' + successCounts.magenta + '/' + successCounts.yellow;
      }

      requestAnimationFrame(scanFrame);
    }

    function drawPreview(data, srcSize, ctx, dstSize) {
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = srcSize;
      tempCanvas.height = srcSize;
      const tempCtx = tempCanvas.getContext('2d');
      tempCtx.putImageData(new ImageData(data, srcSize, srcSize), 0, 0);
      ctx.drawImage(tempCanvas, 0, 0, dstSize, dstSize);
    }

    function updateResult(id, code, channel) {
      const el = document.getElementById(id);
      const resultDiv = el.parentElement;
      if (code) {
        el.textContent = code.data;
        resultDiv.classList.add('success');
        resultDiv.classList.remove('failure');
        successCounts[channel]++;
      } else {
        el.textContent = 'No QR detected';
        resultDiv.classList.add('failure');
        resultDiv.classList.remove('success');
      }
    }

    console.log('PCCC Receiver v3 ready');
    console.log('Workflow: Grayscale QR detect → Corner calibration → Matrix correction → Channel decode');
  </script>
</body>
</html>
