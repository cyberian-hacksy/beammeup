<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>QRGB-Finder Sender</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: system-ui, sans-serif;
      background: #1a1a2e;
      color: #e0e0e0;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
    }
    h1 { margin-bottom: 10px; color: #00d4ff; }
    .description {
      max-width: 600px;
      text-align: center;
      margin-bottom: 20px;
      color: #aaa;
      font-size: 0.9em;
    }
    .controls {
      margin-bottom: 15px;
    }
    .composite-section {
      text-align: center;
      margin: 20px 0;
    }
    .composite-section h2 {
      margin-bottom: 15px;
      color: #00d4ff;
    }
    #compositeCanvas {
      border: 3px solid #00d4ff;
      border-radius: 8px;
      image-rendering: pixelated;
    }
    .legend {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      justify-content: center;
      margin: 20px 0;
      max-width: 600px;
    }
    .legend-item {
      display: flex;
      align-items: center;
      gap: 5px;
      font-size: 10px;
      padding: 4px 8px;
      background: #252540;
      border-radius: 4px;
    }
    .legend-box {
      width: 20px;
      height: 20px;
      border-radius: 3px;
      border: 1px solid #444;
    }
    .data-display {
      margin-top: 15px;
      padding: 15px;
      background: #252540;
      border-radius: 8px;
      max-width: 500px;
      font-family: monospace;
      font-size: 11px;
    }
    .data-display div { margin: 4px 0; }
    .data-display .red { color: #ff6666; }
    .data-display .green { color: #66ff66; }
    .data-display .blue { color: #6666ff; }
    .note {
      margin-top: 15px;
      padding: 10px;
      background: #252540;
      border-radius: 8px;
      font-size: 11px;
      color: #888;
      max-width: 600px;
      text-align: center;
    }
  </style>
</head>
<body>
  <h1>QRGB-Finder Sender</h1>
  <p class="description">
    <strong>RGB Encoding:</strong> Same as FMT - dark module = bit ON = dark pixel.<br>
    Standard QR format. Finder patterns provide B/W calibration.
  </p>

  <div id="controls" class="controls"></div>

  <div class="composite-section">
    <h2>QRGB Color QR Code</h2>
    <canvas id="compositeCanvas" width="440" height="440"></canvas>
  </div>

  <div class="legend" id="legend"></div>

  <div class="data-display">
    <div class="red">Red: <span id="dataRed"></span></div>
    <div class="green">Green: <span id="dataGreen"></span></div>
    <div class="blue">Blue: <span id="dataBlue"></span></div>
  </div>

  <div class="note" id="noteDisplay">
    <strong>Layout:</strong> <span id="noteSize">440x440</span> square with <span id="noteMargin">10</span>px margin.<br>
    Same encoding as FMT. Standard QR format. Finder patterns for B/W calibration.
  </div>

  <script src="https://unpkg.com/qrcode-generator@1.4.4/qrcode.js"></script>
  <script type="module">
    import { createDisplaySizeSelector, displaySizeStyles } from './shared/display-size.js';

    // Inject display size selector styles
    const style = document.createElement('style');
    style.textContent = displaySizeStyles;
    document.head.appendChild(style);

    // Test data for each channel
    const DATA_RED = 'RED:QRGB:V1:12345';
    const DATA_GREEN = 'GREEN:QRGB:V1:67890';
    const DATA_BLUE = 'BLUE:QRGB:V1:ABCDE';

    document.getElementById('dataRed').textContent = DATA_RED;
    document.getElementById('dataGreen').textContent = DATA_GREEN;
    document.getElementById('dataBlue').textContent = DATA_BLUE;

    // RGB encoding: same as FMT
    // bit ON (1) = dark pixel, bit OFF (0) = bright pixel
    // Output: [(1-r)*255, (1-g)*255, (1-b)*255]
    function rgbToColor(r, g, b) {
      return [
        Math.round(255 * (1 - r)),
        Math.round(255 * (1 - g)),
        Math.round(255 * (1 - b))
      ];
    }

    // All 8 RGB combinations for legend (same as FMT)
    // bit ON = dark pixel, bit OFF = bright pixel
    const ALL_COLORS = [
      { rgb: [0, 0, 0], label: 'White (000)' },
      { rgb: [0, 0, 1], label: 'Yellow (001)' },
      { rgb: [0, 1, 0], label: 'Magenta (010)' },
      { rgb: [0, 1, 1], label: 'Red (011)' },
      { rgb: [1, 0, 0], label: 'Cyan (100)' },
      { rgb: [1, 0, 1], label: 'Green (101)' },
      { rgb: [1, 1, 0], label: 'Blue (110)' },
      { rgb: [1, 1, 1], label: 'Black (111)' }
    ];

    ALL_COLORS.forEach(c => { c.color = rgbToColor(...c.rgb); });

    // Generate legend
    const legendEl = document.getElementById('legend');
    ALL_COLORS.forEach((c, i) => {
      const item = document.createElement('div');
      item.className = 'legend-item';

      const box = document.createElement('div');
      box.className = 'legend-box';
      box.style.background = 'rgb(' + c.color.join(',') + ')';

      const label = document.createElement('span');
      label.textContent = c.label;

      item.appendChild(box);
      item.appendChild(label);
      legendEl.appendChild(item);
    });

    // Generate QR
    function getQRModules(data) {
      const qr = qrcode(0, 'M');
      qr.addData(data);
      qr.make();
      const count = qr.getModuleCount();
      const modules = [];
      for (let r = 0; r < count; r++) {
        modules[r] = [];
        for (let c = 0; c < count; c++) {
          modules[r][c] = qr.isDark(r, c) ? 1 : 0;
        }
      }
      return { modules, count };
    }

    // Check if position is finder/timing pattern
    function isFinderOrTiming(row, col, size) {
      // Top-left finder (includes separator)
      if (row < 8 && col < 8) return true;
      // Top-right finder
      if (row < 8 && col >= size - 8) return true;
      // Bottom-left finder
      if (row >= size - 8 && col < 8) return true;
      // Timing patterns
      if (row === 6 || col === 6) return true;
      // Alignment pattern for larger QR codes
      if (size > 25) {
        const alignPos = size - 7;
        if (row >= alignPos - 2 && row <= alignPos + 2 &&
            col >= alignPos - 2 && col <= alignPos + 2) return true;
      }
      return false;
    }

    // Pre-generate QR modules (these don't change with canvas size)
    const qrRed = getQRModules(DATA_RED);
    const qrGreen = getQRModules(DATA_GREEN);
    const qrBlue = getQRModules(DATA_BLUE);
    const moduleCount = qrRed.count;

    const canvas = document.getElementById('compositeCanvas');
    const ctx = canvas.getContext('2d');
    const noteSizeEl = document.getElementById('noteSize');
    const noteMarginEl = document.getElementById('noteMargin');

    // Fixed margin around QR code
    const MARGIN = 10;

    // Render QR code at specified canvas size
    function renderQR(canvasSize) {
      // QR fills canvas minus margin on each side
      const qrSize = canvasSize - MARGIN * 2;

      // Update canvas dimensions
      canvas.width = canvasSize;
      canvas.height = canvasSize;

      // Fill with white background (quiet zone)
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(0, 0, canvasSize, canvasSize);

      // Draw QR code centered with margin
      const cellSize = qrSize / moduleCount;
      const qrOffsetX = MARGIN;
      const qrOffsetY = MARGIN;

      for (let row = 0; row < moduleCount; row++) {
        for (let col = 0; col < moduleCount; col++) {
          // Dark module = channel ON (bit 1)
          const r = qrRed.modules[row][col];
          const g = qrGreen.modules[row][col];
          const b = qrBlue.modules[row][col];

          let color;
          if (isFinderOrTiming(row, col, moduleCount)) {
            // Keep finder patterns black/white (use first QR's pattern)
            color = r ? [0, 0, 0] : [255, 255, 255];
          } else {
            // Data area: encode RGB additively
            // Dark module (1) = channel ON = 255
            // Light module (0) = channel OFF = 0
            color = rgbToColor(r, g, b);
          }

          const x = qrOffsetX + col * cellSize;
          const yPos = qrOffsetY + row * cellSize;

          ctx.fillStyle = 'rgb(' + color.join(',') + ')';
          ctx.fillRect(x, yPos, cellSize + 0.5, cellSize + 0.5);
        }
      }

      // No inversion needed - subtractive encoding produces standard QR format directly

      // Update note display using textContent (safe DOM method)
      noteSizeEl.textContent = canvasSize + 'x' + canvasSize;
      noteMarginEl.textContent = MARGIN;

      console.log('QRGB-Finder Sender rendered at', canvasSize + 'x' + canvasSize);
      console.log('Module count:', moduleCount);
      console.log('Margin:', MARGIN, 'px (no corner patches)');
    }

    // Create size selector
    const getSize = createDisplaySizeSelector(
      document.getElementById('controls'),
      (newSize) => renderQR(newSize),
      440 // default size
    );

    // Initial render
    renderQR(440);

    console.log('QRGB-Finder Sender ready');
  </script>
</body>
</html>
