<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3-Level Grayscale - Sender</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: system-ui, sans-serif;
      background: #1a1a2e;
      color: #e0e0e0;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
    }
    h1 { margin-bottom: 10px; color: #00d4ff; }
    .description {
      max-width: 600px;
      text-align: center;
      margin-bottom: 20px;
      color: #aaa;
      font-size: 0.9em;
    }
    .composite-section {
      text-align: center;
      margin: 20px 0;
    }
    .composite-section h2 {
      margin-bottom: 15px;
      color: #00d4ff;
    }
    #compositeCanvas {
      border: 3px solid #00d4ff;
      border-radius: 8px;
    }
    .calibration {
      display: flex;
      gap: 10px;
      margin: 20px 0;
      padding: 15px;
      background: #252540;
      border-radius: 8px;
    }
    .cal-patch {
      width: 80px;
      height: 80px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      font-weight: bold;
      border-radius: 4px;
      flex-direction: column;
    }
    .cal-patch .level { font-size: 16px; }
    .cal-patch .value { font-size: 10px; margin-top: 4px; }
    .legend {
      display: flex;
      gap: 20px;
      margin: 15px 0;
    }
    .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 13px;
    }
    .legend-box {
      width: 30px;
      height: 30px;
      border-radius: 4px;
      border: 1px solid #555;
    }
    .data-display {
      margin-top: 15px;
      padding: 15px;
      background: #252540;
      border-radius: 8px;
      max-width: 500px;
      font-family: monospace;
      font-size: 12px;
    }
    .note {
      margin-top: 15px;
      padding: 10px;
      background: #252540;
      border-radius: 8px;
      font-size: 11px;
      color: #888;
      max-width: 500px;
      text-align: center;
    }
  </style>
</head>
<body>
  <h1>3-Level Grayscale QR</h1>
  <p class="description">
    <strong>Simplified approach:</strong> Only 3 brightness levels for maximum separation.<br>
    Each module encodes ~1.58 bits (log2(3)). More reliable than 4 levels.
  </p>

  <div class="calibration" id="calibration"></div>

  <div class="composite-section">
    <h2>3-Level Grayscale QR</h2>
    <canvas id="compositeCanvas" width="400" height="400"></canvas>
  </div>

  <div class="legend" id="legend"></div>

  <div class="data-display">
    <div>Data A: <span id="dataA"></span></div>
    <div>Data B: <span id="dataB"></span></div>
    <div style="margin-top: 8px; color: #888;">
      Encoding: Each pair of modules encodes one trit (0-2) from each data stream
    </div>
  </div>

  <div class="note">
    <strong>3-level encoding:</strong> Black (0), Gray (127), White (255).<br>
    Gap of 127 between levels vs 85 for 4-level. Should be much easier to distinguish.<br>
    Two QR codes with different data overlaid using brightness levels.
  </div>

  <script src="https://unpkg.com/qrcode-generator@1.4.4/qrcode.js"></script>
  <script>
    const DATA_A = 'GRAY3:STREAM:A:12345';
    const DATA_B = 'GRAY3:STREAM:B:67890';

    document.getElementById('dataA').textContent = DATA_A;
    document.getElementById('dataB').textContent = DATA_B;

    // 3 brightness levels with maximum separation
    const LEVELS = [0, 127, 255];

    // Generate calibration patches
    const calEl = document.getElementById('calibration');
    for (let i = 0; i < 3; i++) {
      const patch = document.createElement('div');
      patch.className = 'cal-patch';
      patch.style.background = 'rgb(' + LEVELS[i] + ',' + LEVELS[i] + ',' + LEVELS[i] + ')';
      patch.style.color = i < 2 ? '#fff' : '#000';

      const levelSpan = document.createElement('span');
      levelSpan.className = 'level';
      levelSpan.textContent = 'L' + i;

      const valueSpan = document.createElement('span');
      valueSpan.className = 'value';
      valueSpan.textContent = LEVELS[i];

      patch.appendChild(levelSpan);
      patch.appendChild(valueSpan);
      calEl.appendChild(patch);
    }

    // Generate legend
    const legendEl = document.getElementById('legend');
    const labels = ['0 (Black)', '1 (Gray)', '2 (White)'];
    for (let i = 0; i < 3; i++) {
      const item = document.createElement('div');
      item.className = 'legend-item';

      const box = document.createElement('div');
      box.className = 'legend-box';
      box.style.background = 'rgb(' + LEVELS[i] + ',' + LEVELS[i] + ',' + LEVELS[i] + ')';

      const label = document.createElement('span');
      label.textContent = labels[i];

      item.appendChild(box);
      item.appendChild(label);
      legendEl.appendChild(item);
    }

    // Generate QR and return module data
    function getQRModules(data) {
      const qr = qrcode(0, 'M');
      qr.addData(data);
      qr.make();
      const count = qr.getModuleCount();
      const modules = [];
      for (let r = 0; r < count; r++) {
        modules[r] = [];
        for (let c = 0; c < count; c++) {
          modules[r][c] = qr.isDark(r, c) ? 1 : 0;
        }
      }
      return { modules, count };
    }

    // Helper: check if position is part of finder pattern or timing
    function isFinderOrTiming(row, col, size) {
      // Top-left finder (0-6, 0-6) + separator
      if (row < 8 && col < 8) return true;
      // Top-right finder
      if (row < 8 && col >= size - 8) return true;
      // Bottom-left finder
      if (row >= size - 8 && col < 8) return true;
      // Timing patterns
      if (row === 6 || col === 6) return true;
      return false;
    }

    const qrA = getQRModules(DATA_A);
    const qrB = getQRModules(DATA_B);
    const moduleCount = qrA.count;

    const compositeSize = 400;
    const canvas = document.getElementById('compositeCanvas');
    const ctx = canvas.getContext('2d');
    const cellSize = compositeSize / moduleCount;

    const imageData = ctx.createImageData(compositeSize, compositeSize);
    const pixels = imageData.data;

    for (let row = 0; row < moduleCount; row++) {
      for (let col = 0; col < moduleCount; col++) {
        const aBit = qrA.modules[row][col];
        const bBit = qrB.modules[row][col];
        let gray;

        if (isFinderOrTiming(row, col, moduleCount)) {
          // Keep finder patterns binary for QR detection
          // Use the A QR code's pattern for finders
          gray = aBit ? LEVELS[0] : LEVELS[2];
        } else {
          // Data area: combine two bits into 3 levels
          // 00 -> Level 0 (black)
          // 01 or 10 -> Level 1 (gray)
          // 11 -> Level 2 (white)
          // This loses some information but is simple

          // Alternative: treat as base-2 number and map to nearest level
          // For now, simple XOR-style:
          // A=0,B=0 -> 0 (black)
          // A=1,B=0 -> 1 (gray)
          // A=0,B=1 -> 1 (gray) -- ambiguous with above
          // A=1,B=1 -> 2 (white)

          // Better: Use A for level selection, B encoded differently
          // Actually simplest: A determines dark/light, B shifts within
          // A=0: use 0 or 1 based on B
          // A=1: use 1 or 2 based on B
          // But this creates ambiguity at level 1

          // Cleanest for 3 levels with 2 QRs:
          // Encode A+B as the level (0, 1, or 2)
          // A=0,B=0 -> 0, A=1,B=0 or A=0,B=1 -> 1, A=1,B=1 -> 2
          const sum = aBit + bBit;
          gray = LEVELS[sum];
        }

        // Fill cell
        const startX = Math.floor(col * cellSize);
        const startY = Math.floor(row * cellSize);
        const endX = Math.floor((col + 1) * cellSize);
        const endY = Math.floor((row + 1) * cellSize);

        for (let y = startY; y < endY; y++) {
          for (let x = startX; x < endX; x++) {
            const idx = (y * compositeSize + x) * 4;
            pixels[idx] = gray;
            pixels[idx + 1] = gray;
            pixels[idx + 2] = gray;
            pixels[idx + 3] = 255;
          }
        }
      }
    }

    ctx.putImageData(imageData, 0, 0);
    console.log('Gray3 Sender ready');
    console.log('Levels:', LEVELS);
  </script>
</body>
</html>
