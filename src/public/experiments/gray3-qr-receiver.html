<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3-Level Grayscale - Receiver</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: system-ui, sans-serif;
      background: #1a1a2e;
      color: #e0e0e0;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 10px;
    }
    h1 { margin-bottom: 5px; color: #00d4ff; font-size: 1.4em; }
    .description {
      text-align: center;
      margin-bottom: 10px;
      color: #aaa;
      font-size: 0.85em;
    }
    #video {
      width: 100%;
      max-width: 400px;
      border: 2px solid #333;
      border-radius: 8px;
    }
    #captureCanvas { display: none; }
    .previews {
      display: flex;
      gap: 8px;
      margin: 10px 0;
      flex-wrap: wrap;
      justify-content: center;
    }
    .preview { text-align: center; }
    .preview canvas {
      border: 2px solid #333;
      border-radius: 4px;
    }
    .preview p { margin-top: 4px; font-size: 10px; color: #aaa; }
    .analysis {
      width: 100%;
      max-width: 400px;
      margin: 10px 0;
      padding: 10px;
      background: #252540;
      border-radius: 8px;
    }
    .analysis h3 {
      font-size: 12px;
      color: #00d4ff;
      margin-bottom: 8px;
    }
    #histogramCanvas {
      width: 100%;
      height: 60px;
      background: #1a1a2e;
      border-radius: 4px;
    }
    .level-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
      margin-top: 10px;
    }
    .level-box {
      text-align: center;
      padding: 10px;
      background: #1a1a2e;
      border-radius: 4px;
    }
    .level-box .name { font-size: 11px; color: #888; }
    .level-box .value { font-size: 16px; color: #00d4ff; font-weight: bold; }
    .level-box .range { font-size: 9px; color: #666; }
    .metrics {
      display: flex;
      justify-content: space-around;
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px solid #333;
    }
    .metric { text-align: center; }
    .metric .label { font-size: 10px; color: #888; }
    .metric .value { font-size: 14px; font-weight: bold; }
    .metric .value.good { color: #6bff6b; }
    .metric .value.fair { color: #ffff6b; }
    .metric .value.poor { color: #ff6b6b; }
    .results {
      width: 100%;
      max-width: 400px;
      padding: 10px;
      background: #252540;
      border-radius: 8px;
      font-size: 11px;
    }
    .result-row {
      display: flex;
      justify-content: space-between;
      margin: 4px 0;
      padding: 4px;
      background: #1a1a2e;
      border-radius: 4px;
    }
    .result-row .label { color: #888; }
    .result-row .value { color: #00d4ff; }
    .result-row.success { border-left: 3px solid #6bff6b; }
    .result-row.failure { border-left: 3px solid #ff6b6b; }
    button {
      margin: 10px;
      padding: 10px 20px;
      background: #00d4ff;
      color: #1a1a2e;
      border: none;
      border-radius: 4px;
      font-weight: bold;
      cursor: pointer;
    }
    button:disabled { background: #333; color: #666; }
  </style>
</head>
<body>
  <h1>Gray3 Receiver</h1>
  <p class="description">Detects 3 brightness levels, reconstructs two QR codes</p>

  <button id="startBtn">Start Camera</button>
  <video id="video" autoplay playsinline></video>
  <canvas id="captureCanvas"></canvas>

  <div class="previews">
    <div class="preview">
      <canvas id="grayPreview" width="100" height="100"></canvas>
      <p>Grayscale</p>
    </div>
    <div class="preview">
      <canvas id="quantizedPreview" width="100" height="100"></canvas>
      <p>Quantized</p>
    </div>
    <div class="preview">
      <canvas id="qrAPreview" width="100" height="100"></canvas>
      <p>QR A</p>
    </div>
    <div class="preview">
      <canvas id="qrBPreview" width="100" height="100"></canvas>
      <p>QR B</p>
    </div>
  </div>

  <div class="analysis">
    <h3>Brightness Histogram</h3>
    <canvas id="histogramCanvas" width="380" height="60"></canvas>

    <div class="level-grid">
      <div class="level-box">
        <div class="name">Level 0 (Black)</div>
        <div class="value" id="level0val">-</div>
        <div class="range" id="level0range">-</div>
      </div>
      <div class="level-box">
        <div class="name">Level 1 (Gray)</div>
        <div class="value" id="level1val">-</div>
        <div class="range" id="level1range">-</div>
      </div>
      <div class="level-box">
        <div class="name">Level 2 (White)</div>
        <div class="value" id="level2val">-</div>
        <div class="range" id="level2range">-</div>
      </div>
    </div>

    <div class="metrics">
      <div class="metric">
        <div class="label">Peaks</div>
        <div class="value" id="peakCount">-</div>
      </div>
      <div class="metric">
        <div class="label">Min Gap</div>
        <div class="value" id="minGap">-</div>
      </div>
      <div class="metric">
        <div class="label">Separation</div>
        <div class="value" id="separation">-</div>
      </div>
    </div>
  </div>

  <div class="results">
    <div class="result-row" id="qrAResult">
      <span class="label">QR A (dark):</span>
      <span class="value">-</span>
    </div>
    <div class="result-row" id="qrBResult">
      <span class="label">QR B (light):</span>
      <span class="value">-</span>
    </div>
  </div>

  <script src="https://unpkg.com/jsqr@1.4.0/dist/jsQR.js"></script>
  <script>
    const video = document.getElementById('video');
    const captureCanvas = document.getElementById('captureCanvas');
    const captureCtx = captureCanvas.getContext('2d', { willReadFrequently: true });
    const startBtn = document.getElementById('startBtn');

    const grayPreview = document.getElementById('grayPreview');
    const grayCtx = grayPreview.getContext('2d');
    const quantizedPreview = document.getElementById('quantizedPreview');
    const quantizedCtx = quantizedPreview.getContext('2d');
    const qrAPreview = document.getElementById('qrAPreview');
    const qrACtx = qrAPreview.getContext('2d');
    const qrBPreview = document.getElementById('qrBPreview');
    const qrBCtx = qrBPreview.getContext('2d');
    const histogramCanvas = document.getElementById('histogramCanvas');
    const histCtx = histogramCanvas.getContext('2d');

    let scanning = false;

    startBtn.addEventListener('click', async () => {
      try {
        video.srcObject = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: 'environment', width: { ideal: 720 }, height: { ideal: 720 } }
        });
        video.play();
        startBtn.disabled = true;
        startBtn.textContent = 'Scanning...';
        scanning = true;
        requestAnimationFrame(scanFrame);
      } catch (err) {
        alert('Camera error: ' + err.message);
      }
    });

    function findPeaks(histogram) {
      // Smooth histogram
      const smoothed = [];
      const window = 10;
      for (let i = 0; i < 256; i++) {
        let sum = 0, count = 0;
        for (let j = Math.max(0, i - window); j <= Math.min(255, i + window); j++) {
          sum += histogram[j];
          count++;
        }
        smoothed[i] = sum / count;
      }

      // Find local maxima
      const peaks = [];
      const minHeight = Math.max(...smoothed) * 0.05;

      for (let i = 15; i < 241; i++) {
        if (smoothed[i] > smoothed[i - 15] &&
            smoothed[i] > smoothed[i + 15] &&
            smoothed[i] > minHeight) {
          // Not too close to previous peak
          if (peaks.length === 0 || i - peaks[peaks.length - 1].pos > 40) {
            peaks.push({ pos: i, height: smoothed[i] });
          } else if (smoothed[i] > peaks[peaks.length - 1].height) {
            peaks[peaks.length - 1] = { pos: i, height: smoothed[i] };
          }
        }
      }

      return peaks;
    }

    function calculateThresholds(peaks) {
      if (peaks.length >= 3) {
        peaks.sort((a, b) => a.pos - b.pos);
        return [
          Math.round((peaks[0].pos + peaks[1].pos) / 2),
          Math.round((peaks[1].pos + peaks[2].pos) / 2)
        ];
      }
      // Fallback
      return [85, 170];
    }

    function scanFrame() {
      if (!scanning) return;

      if (video.readyState === video.HAVE_ENOUGH_DATA) {
        const size = Math.min(video.videoWidth, video.videoHeight);
        captureCanvas.width = size;
        captureCanvas.height = size;

        const offsetX = (video.videoWidth - size) / 2;
        const offsetY = (video.videoHeight - size) / 2;
        captureCtx.drawImage(video, offsetX, offsetY, size, size, 0, 0, size, size);

        const imageData = captureCtx.getImageData(0, 0, size, size);
        const pixels = imageData.data;

        // Convert to grayscale and build histogram
        const histogram = new Array(256).fill(0);
        const grayValues = new Uint8Array(size * size);

        for (let i = 0; i < size * size; i++) {
          const idx = i * 4;
          const r = pixels[idx];
          const g = pixels[idx + 1];
          const b = pixels[idx + 2];
          const gray = Math.round(0.299 * r + 0.587 * g + 0.114 * b);
          grayValues[i] = gray;
          histogram[gray]++;
        }

        // Draw grayscale preview
        const grayData = new Uint8ClampedArray(size * size * 4);
        for (let i = 0; i < size * size; i++) {
          const idx = i * 4;
          grayData[idx] = grayValues[i];
          grayData[idx + 1] = grayValues[i];
          grayData[idx + 2] = grayValues[i];
          grayData[idx + 3] = 255;
        }
        drawPreview(grayData, size, grayCtx, 100);

        // Find peaks and calculate thresholds
        const peaks = findPeaks(histogram);
        const thresholds = calculateThresholds(peaks);

        // Update level displays
        const levelCenters = peaks.slice(0, 3).map(p => p.pos).sort((a, b) => a - b);
        for (let i = 0; i < 3; i++) {
          const valEl = document.getElementById('level' + i + 'val');
          const rangeEl = document.getElementById('level' + i + 'range');
          if (levelCenters[i] !== undefined) {
            valEl.textContent = levelCenters[i];
            const low = i === 0 ? 0 : thresholds[i - 1];
            const high = i === 2 ? 255 : thresholds[i];
            rangeEl.textContent = low + '-' + high;
          } else {
            valEl.textContent = '-';
            rangeEl.textContent = '-';
          }
        }

        // Calculate separation metrics
        let minGap = 255;
        for (let i = 1; i < levelCenters.length && i < 3; i++) {
          const gap = levelCenters[i] - levelCenters[i - 1];
          if (gap < minGap) minGap = gap;
        }

        const peakCountEl = document.getElementById('peakCount');
        const minGapEl = document.getElementById('minGap');
        const separationEl = document.getElementById('separation');

        peakCountEl.textContent = peaks.length;
        peakCountEl.className = 'value ' + (peaks.length >= 3 ? 'good' : peaks.length >= 2 ? 'fair' : 'poor');

        minGapEl.textContent = minGap;
        minGapEl.className = 'value ' + (minGap > 60 ? 'good' : minGap > 40 ? 'fair' : 'poor');

        let separation = 'Poor';
        if (peaks.length >= 3 && minGap > 60) separation = 'Good';
        else if (peaks.length >= 3 && minGap > 40) separation = 'Fair';
        else if (peaks.length >= 2) separation = 'Marginal';
        separationEl.textContent = separation;
        separationEl.className = 'value ' + (separation === 'Good' ? 'good' : separation === 'Fair' ? 'fair' : 'poor');

        // Quantize to 3 levels and create QR images
        const quantizedData = new Uint8ClampedArray(size * size * 4);
        const qrAData = new Uint8ClampedArray(size * size * 4);
        const qrBData = new Uint8ClampedArray(size * size * 4);

        for (let i = 0; i < size * size; i++) {
          const idx = i * 4;
          const gray = grayValues[i];

          // Quantize to level 0, 1, or 2
          let level;
          if (gray < thresholds[0]) level = 0;
          else if (gray < thresholds[1]) level = 1;
          else level = 2;

          // Quantized preview
          const qVal = level === 0 ? 0 : level === 1 ? 127 : 255;
          quantizedData[idx] = qVal;
          quantizedData[idx + 1] = qVal;
          quantizedData[idx + 2] = qVal;
          quantizedData[idx + 3] = 255;

          // Reconstruct QR A and B from levels
          // Encoding was: level = A + B
          // Level 0: A=0, B=0 -> A dark, B dark
          // Level 1: A=1, B=0 OR A=0, B=1 -> ambiguous
          // Level 2: A=1, B=1 -> A light, B light

          // For QR A: treat level 0 as dark, levels 1,2 as light
          // For QR B: treat levels 0,1 as dark, level 2 as light
          // This gives us: A recovers original A pattern, B recovers original B pattern

          const aDark = level === 0 ? 0 : 255;  // A is dark only at level 0
          const bDark = level === 2 ? 255 : 0;  // B is light only at level 2

          qrAData[idx] = aDark;
          qrAData[idx + 1] = aDark;
          qrAData[idx + 2] = aDark;
          qrAData[idx + 3] = 255;

          qrBData[idx] = bDark;
          qrBData[idx + 1] = bDark;
          qrBData[idx + 2] = bDark;
          qrBData[idx + 3] = 255;
        }

        drawPreview(quantizedData, size, quantizedCtx, 100);
        drawPreview(qrAData, size, qrACtx, 100);
        drawPreview(qrBData, size, qrBCtx, 100);

        // Draw histogram
        drawHistogram(histogram, thresholds, peaks);

        // Try QR decode
        const qrACode = jsQR(qrAData, size, size);
        const qrBCode = jsQR(qrBData, size, size);

        updateResult('qrAResult', qrACode);
        updateResult('qrBResult', qrBCode);
      }

      requestAnimationFrame(scanFrame);
    }

    function drawPreview(data, srcSize, ctx, dstSize) {
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = srcSize;
      tempCanvas.height = srcSize;
      const tempCtx = tempCanvas.getContext('2d');
      tempCtx.putImageData(new ImageData(data, srcSize, srcSize), 0, 0);
      ctx.drawImage(tempCanvas, 0, 0, dstSize, dstSize);
    }

    function updateResult(id, code) {
      const el = document.getElementById(id);
      const valueEl = el.querySelector('.value');
      if (code) {
        valueEl.textContent = code.data.length > 25 ? code.data.substring(0, 25) + '...' : code.data;
        el.classList.add('success');
        el.classList.remove('failure');
      } else {
        valueEl.textContent = 'No QR detected';
        el.classList.add('failure');
        el.classList.remove('success');
      }
    }

    function drawHistogram(histogram, thresholds, peaks) {
      const width = histogramCanvas.width;
      const height = histogramCanvas.height;
      histCtx.fillStyle = '#1a1a2e';
      histCtx.fillRect(0, 0, width, height);

      const max = Math.max(...histogram);
      const barWidth = width / 256;

      // Draw histogram bars
      histCtx.fillStyle = '#00d4ff';
      for (let i = 0; i < 256; i++) {
        const barHeight = (histogram[i] / max) * (height - 5);
        histCtx.fillRect(i * barWidth, height - barHeight, barWidth, barHeight);
      }

      // Draw threshold lines
      histCtx.strokeStyle = '#ff6b6b';
      histCtx.lineWidth = 2;
      for (const t of thresholds) {
        const x = (t / 256) * width;
        histCtx.beginPath();
        histCtx.moveTo(x, 0);
        histCtx.lineTo(x, height);
        histCtx.stroke();
      }

      // Mark peaks
      histCtx.fillStyle = '#6bff6b';
      for (const peak of peaks.slice(0, 3)) {
        const x = (peak.pos / 256) * width;
        histCtx.beginPath();
        histCtx.arc(x, 5, 4, 0, Math.PI * 2);
        histCtx.fill();
      }
    }

    console.log('Gray3 Receiver ready');
  </script>
</body>
</html>
