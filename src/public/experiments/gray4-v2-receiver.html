<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>4-Level Grayscale v2 - Receiver</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: system-ui, sans-serif;
      background: #1a1a2e;
      color: #e0e0e0;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 10px;
    }
    h1 { margin-bottom: 5px; color: #00d4ff; font-size: 1.4em; }
    .description {
      text-align: center;
      margin-bottom: 10px;
      color: #aaa;
      font-size: 0.85em;
    }
    #video {
      width: 100%;
      max-width: 400px;
      border: 2px solid #333;
      border-radius: 8px;
    }
    #captureCanvas { display: none; }
    .previews {
      display: flex;
      gap: 10px;
      margin: 10px 0;
      flex-wrap: wrap;
      justify-content: center;
    }
    .preview { text-align: center; }
    .preview canvas {
      border: 2px solid #333;
      border-radius: 4px;
    }
    .preview p { margin-top: 4px; font-size: 11px; color: #aaa; }
    .analysis {
      width: 100%;
      max-width: 400px;
      margin: 10px 0;
      padding: 10px;
      background: #252540;
      border-radius: 8px;
    }
    .analysis h3 {
      font-size: 12px;
      color: #00d4ff;
      margin-bottom: 8px;
    }
    #histogramCanvas {
      width: 100%;
      height: 80px;
      background: #1a1a2e;
      border-radius: 4px;
    }
    .level-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 8px;
      margin-top: 10px;
    }
    .level-box {
      text-align: center;
      padding: 8px;
      background: #1a1a2e;
      border-radius: 4px;
    }
    .level-box .name { font-size: 10px; color: #888; }
    .level-box .value { font-size: 14px; color: #00d4ff; font-weight: bold; }
    .level-box .range { font-size: 9px; color: #666; }
    .metrics {
      display: flex;
      justify-content: space-around;
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px solid #333;
    }
    .metric {
      text-align: center;
    }
    .metric .label { font-size: 10px; color: #888; }
    .metric .value { font-size: 14px; font-weight: bold; }
    .metric .value.good { color: #6bff6b; }
    .metric .value.fair { color: #ffff6b; }
    .metric .value.poor { color: #ff6b6b; }
    .results {
      width: 100%;
      max-width: 400px;
      padding: 10px;
      background: #252540;
      border-radius: 8px;
      font-size: 11px;
    }
    .result-row {
      display: flex;
      justify-content: space-between;
      margin: 4px 0;
    }
    .result-row .label { color: #888; }
    .result-row .value { color: #00d4ff; }
    .result-row.success .value { color: #6bff6b; }
    .result-row.failure .value { color: #ff6b6b; }
    button {
      margin: 10px;
      padding: 10px 20px;
      background: #00d4ff;
      color: #1a1a2e;
      border: none;
      border-radius: 4px;
      font-weight: bold;
      cursor: pointer;
    }
    button:disabled { background: #333; color: #666; }
  </style>
</head>
<body>
  <h1>Gray4 v2 Receiver</h1>
  <p class="description">Improved analysis with adaptive level detection</p>

  <button id="startBtn">Start Camera</button>
  <video id="video" autoplay playsinline></video>
  <canvas id="captureCanvas"></canvas>

  <div class="previews">
    <div class="preview">
      <canvas id="grayPreview" width="140" height="140"></canvas>
      <p>Grayscale</p>
    </div>
    <div class="preview">
      <canvas id="quantizedPreview" width="140" height="140"></canvas>
      <p>Quantized</p>
    </div>
  </div>

  <div class="analysis">
    <h3>Brightness Histogram &amp; Level Detection</h3>
    <canvas id="histogramCanvas" width="380" height="80"></canvas>

    <div class="level-grid">
      <div class="level-box">
        <div class="name">Level 0</div>
        <div class="value" id="level0val">-</div>
        <div class="range" id="level0range">-</div>
      </div>
      <div class="level-box">
        <div class="name">Level 1</div>
        <div class="value" id="level1val">-</div>
        <div class="range" id="level1range">-</div>
      </div>
      <div class="level-box">
        <div class="name">Level 2</div>
        <div class="value" id="level2val">-</div>
        <div class="range" id="level2range">-</div>
      </div>
      <div class="level-box">
        <div class="name">Level 3</div>
        <div class="value" id="level3val">-</div>
        <div class="range" id="level3range">-</div>
      </div>
    </div>

    <div class="metrics">
      <div class="metric">
        <div class="label">Peaks Found</div>
        <div class="value" id="peakCount">-</div>
      </div>
      <div class="metric">
        <div class="label">Min Gap</div>
        <div class="value" id="minGap">-</div>
      </div>
      <div class="metric">
        <div class="label">Separation</div>
        <div class="value" id="separation">-</div>
      </div>
    </div>
  </div>

  <div class="results">
    <div class="result-row" id="qrDetect">
      <span class="label">QR Structure:</span>
      <span class="value">-</span>
    </div>
    <div class="result-row" id="qrData">
      <span class="label">Base Data:</span>
      <span class="value">-</span>
    </div>
  </div>

  <script src="https://unpkg.com/jsqr@1.4.0/dist/jsQR.js"></script>
  <script>
    const video = document.getElementById('video');
    const captureCanvas = document.getElementById('captureCanvas');
    const captureCtx = captureCanvas.getContext('2d', { willReadFrequently: true });
    const startBtn = document.getElementById('startBtn');

    const grayPreview = document.getElementById('grayPreview');
    const grayCtx = grayPreview.getContext('2d');
    const quantizedPreview = document.getElementById('quantizedPreview');
    const quantizedCtx = quantizedPreview.getContext('2d');
    const histogramCanvas = document.getElementById('histogramCanvas');
    const histCtx = histogramCanvas.getContext('2d');

    let scanning = false;

    startBtn.addEventListener('click', async () => {
      try {
        video.srcObject = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: 'environment', width: { ideal: 720 }, height: { ideal: 720 } }
        });
        video.play();
        startBtn.disabled = true;
        startBtn.textContent = 'Scanning...';
        scanning = true;
        requestAnimationFrame(scanFrame);
      } catch (err) {
        alert('Camera error: ' + err.message);
      }
    });

    function findPeaks(histogram) {
      // Smooth histogram
      const smoothed = [];
      const window = 8;
      for (let i = 0; i < 256; i++) {
        let sum = 0, count = 0;
        for (let j = Math.max(0, i - window); j <= Math.min(255, i + window); j++) {
          sum += histogram[j];
          count++;
        }
        smoothed[i] = sum / count;
      }

      // Find local maxima
      const peaks = [];
      const minHeight = Math.max(...smoothed) * 0.05;

      for (let i = 10; i < 246; i++) {
        if (smoothed[i] > smoothed[i - 10] &&
            smoothed[i] > smoothed[i + 10] &&
            smoothed[i] > minHeight) {
          // Not too close to previous peak
          if (peaks.length === 0 || i - peaks[peaks.length - 1].pos > 25) {
            peaks.push({ pos: i, height: smoothed[i] });
          } else if (smoothed[i] > peaks[peaks.length - 1].height) {
            // Replace previous peak if this one is higher
            peaks[peaks.length - 1] = { pos: i, height: smoothed[i] };
          }
        }
      }

      return peaks;
    }

    function calculateThresholds(peaks) {
      // If we found 4 peaks, set thresholds between them
      if (peaks.length >= 4) {
        // Sort by position
        peaks.sort((a, b) => a.pos - b.pos);
        const top4 = peaks.slice(0, 4);
        return [
          Math.round((top4[0].pos + top4[1].pos) / 2),
          Math.round((top4[1].pos + top4[2].pos) / 2),
          Math.round((top4[2].pos + top4[3].pos) / 2)
        ];
      }
      // Fallback to even distribution
      return [64, 128, 192];
    }

    function scanFrame() {
      if (!scanning) return;

      if (video.readyState === video.HAVE_ENOUGH_DATA) {
        const size = Math.min(video.videoWidth, video.videoHeight);
        captureCanvas.width = size;
        captureCanvas.height = size;

        const offsetX = (video.videoWidth - size) / 2;
        const offsetY = (video.videoHeight - size) / 2;
        captureCtx.drawImage(video, offsetX, offsetY, size, size, 0, 0, size, size);

        const imageData = captureCtx.getImageData(0, 0, size, size);
        const pixels = imageData.data;

        // Convert to grayscale and build histogram
        const histogram = new Array(256).fill(0);
        const grayData = new Uint8ClampedArray(size * size * 4);

        for (let i = 0; i < size * size; i++) {
          const idx = i * 4;
          const r = pixels[idx];
          const g = pixels[idx + 1];
          const b = pixels[idx + 2];
          const gray = Math.round(0.299 * r + 0.587 * g + 0.114 * b);
          histogram[gray]++;
          grayData[idx] = gray;
          grayData[idx + 1] = gray;
          grayData[idx + 2] = gray;
          grayData[idx + 3] = 255;
        }

        // Draw grayscale preview
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = size;
        tempCanvas.height = size;
        const tempCtx = tempCanvas.getContext('2d');
        tempCtx.putImageData(new ImageData(grayData, size, size), 0, 0);
        grayCtx.drawImage(tempCanvas, 0, 0, 140, 140);

        // Find peaks and calculate thresholds
        const peaks = findPeaks(histogram);
        const thresholds = calculateThresholds(peaks);

        // Update level displays
        const levelCenters = peaks.slice(0, 4).map(p => p.pos).sort((a, b) => a - b);
        for (let i = 0; i < 4; i++) {
          const valEl = document.getElementById('level' + i + 'val');
          const rangeEl = document.getElementById('level' + i + 'range');
          if (levelCenters[i] !== undefined) {
            valEl.textContent = levelCenters[i];
            const low = i === 0 ? 0 : thresholds[i - 1];
            const high = i === 3 ? 255 : thresholds[i];
            rangeEl.textContent = low + '-' + high;
          } else {
            valEl.textContent = '-';
            rangeEl.textContent = '-';
          }
        }

        // Calculate separation metrics
        let minGap = 255;
        for (let i = 1; i < levelCenters.length && i < 4; i++) {
          const gap = levelCenters[i] - levelCenters[i - 1];
          if (gap < minGap) minGap = gap;
        }

        const peakCountEl = document.getElementById('peakCount');
        const minGapEl = document.getElementById('minGap');
        const separationEl = document.getElementById('separation');

        peakCountEl.textContent = peaks.length;
        peakCountEl.className = 'value ' + (peaks.length >= 4 ? 'good' : peaks.length >= 3 ? 'fair' : 'poor');

        minGapEl.textContent = minGap;
        minGapEl.className = 'value ' + (minGap > 40 ? 'good' : minGap > 25 ? 'fair' : 'poor');

        let separation = 'Poor';
        if (peaks.length >= 4 && minGap > 40) separation = 'Good';
        else if (peaks.length >= 4 && minGap > 25) separation = 'Fair';
        else if (peaks.length >= 3) separation = 'Marginal';
        separationEl.textContent = separation;
        separationEl.className = 'value ' + (separation === 'Good' ? 'good' : separation === 'Fair' ? 'fair' : 'poor');

        // Quantize image
        const quantizedData = new Uint8ClampedArray(size * size * 4);
        const levelValues = [0, 85, 170, 255];

        for (let i = 0; i < size * size; i++) {
          const idx = i * 4;
          const gray = grayData[idx];
          let level;
          if (gray < thresholds[0]) level = 0;
          else if (gray < thresholds[1]) level = 1;
          else if (gray < thresholds[2]) level = 2;
          else level = 3;

          const qVal = levelValues[level];
          quantizedData[idx] = qVal;
          quantizedData[idx + 1] = qVal;
          quantizedData[idx + 2] = qVal;
          quantizedData[idx + 3] = 255;
        }

        tempCtx.putImageData(new ImageData(quantizedData, size, size), 0, 0);
        quantizedCtx.drawImage(tempCanvas, 0, 0, 140, 140);

        // Draw histogram
        drawHistogram(histogram, thresholds, peaks);

        // Try QR decode
        const qrCode = jsQR(grayData, size, size);
        const qrDetect = document.getElementById('qrDetect');
        const qrData = document.getElementById('qrData');

        if (qrCode) {
          qrDetect.classList.add('success');
          qrDetect.classList.remove('failure');
          qrDetect.querySelector('.value').textContent = 'Detected';
          const dataText = qrCode.data.length > 30 ? qrCode.data.substring(0, 30) + '...' : qrCode.data;
          qrData.querySelector('.value').textContent = dataText;
        } else {
          qrDetect.classList.add('failure');
          qrDetect.classList.remove('success');
          qrDetect.querySelector('.value').textContent = 'Not found';
          qrData.querySelector('.value').textContent = '-';
        }
      }

      requestAnimationFrame(scanFrame);
    }

    function drawHistogram(histogram, thresholds, peaks) {
      const width = histogramCanvas.width;
      const height = histogramCanvas.height;
      histCtx.fillStyle = '#1a1a2e';
      histCtx.fillRect(0, 0, width, height);

      const max = Math.max(...histogram);
      const barWidth = width / 256;

      // Draw histogram bars
      histCtx.fillStyle = '#00d4ff';
      for (let i = 0; i < 256; i++) {
        const barHeight = (histogram[i] / max) * (height - 5);
        histCtx.fillRect(i * barWidth, height - barHeight, barWidth, barHeight);
      }

      // Draw threshold lines
      histCtx.strokeStyle = '#ff6b6b';
      histCtx.lineWidth = 1;
      for (const t of thresholds) {
        const x = (t / 256) * width;
        histCtx.beginPath();
        histCtx.moveTo(x, 0);
        histCtx.lineTo(x, height);
        histCtx.stroke();
      }

      // Mark peaks
      histCtx.fillStyle = '#6bff6b';
      for (const peak of peaks.slice(0, 4)) {
        const x = (peak.pos / 256) * width;
        histCtx.beginPath();
        histCtx.arc(x, 5, 4, 0, Math.PI * 2);
        histCtx.fill();
      }
    }

    console.log('Gray4 v2 Receiver ready');
  </script>
</body>
</html>
