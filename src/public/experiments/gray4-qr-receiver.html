<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>4-Level Grayscale QR Receiver - Experiment</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: system-ui, sans-serif;
      background: #1a1a2e;
      color: #e0e0e0;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 10px;
    }
    h1 { margin-bottom: 5px; color: #00d4ff; font-size: 1.4em; }
    .description {
      text-align: center;
      margin-bottom: 10px;
      color: #aaa;
      font-size: 0.9em;
    }
    #video {
      width: 100%;
      max-width: 400px;
      border: 2px solid #333;
      border-radius: 8px;
    }
    #captureCanvas { display: none; }
    .previews {
      display: flex;
      gap: 10px;
      margin: 10px 0;
      flex-wrap: wrap;
      justify-content: center;
    }
    .preview { text-align: center; }
    .preview canvas {
      border: 2px solid #333;
      border-radius: 4px;
    }
    .preview p { margin-top: 4px; font-size: 12px; color: #aaa; }
    .histogram {
      width: 100%;
      max-width: 400px;
      margin: 10px 0;
      padding: 10px;
      background: #252540;
      border-radius: 8px;
    }
    .histogram h3 {
      font-size: 12px;
      color: #00d4ff;
      margin-bottom: 8px;
    }
    #histogramCanvas {
      width: 100%;
      height: 100px;
      background: #1a1a2e;
      border-radius: 4px;
    }
    .thresholds {
      display: flex;
      justify-content: space-around;
      margin-top: 8px;
      font-size: 11px;
      color: #888;
    }
    .level-stats {
      display: flex;
      justify-content: space-around;
      margin-top: 10px;
    }
    .level-stat {
      text-align: center;
      font-size: 11px;
    }
    .level-stat .value { color: #00d4ff; font-weight: bold; }
    .results {
      width: 100%;
      max-width: 400px;
      padding: 15px;
      background: #252540;
      border-radius: 8px;
      font-family: monospace;
      font-size: 12px;
    }
    .result-row {
      display: flex;
      justify-content: space-between;
      margin: 5px 0;
    }
    .result-row .label { color: #888; }
    .result-row .value { color: #00d4ff; }
    .result-row.success .value { color: #6bff6b; }
    .result-row.failure .value { color: #ff6b6b; }
    button {
      margin: 10px;
      padding: 10px 20px;
      background: #00d4ff;
      color: #1a1a2e;
      border: none;
      border-radius: 4px;
      font-weight: bold;
      cursor: pointer;
    }
    button:disabled { background: #333; color: #666; }
    .note {
      margin-top: 10px;
      padding: 8px;
      background: #252540;
      border-radius: 4px;
      font-size: 11px;
      color: #888;
      max-width: 400px;
      text-align: center;
    }
  </style>
</head>
<body>
  <h1>4-Level Grayscale Receiver</h1>
  <p class="description">Tests if camera can distinguish 4 gray levels reliably</p>

  <button id="startBtn">Start Camera</button>
  <video id="video" autoplay playsinline></video>
  <canvas id="captureCanvas"></canvas>

  <div class="previews">
    <div class="preview">
      <canvas id="grayPreview" width="150" height="150"></canvas>
      <p>Grayscale</p>
    </div>
    <div class="preview">
      <canvas id="quantizedPreview" width="150" height="150"></canvas>
      <p>Quantized (4 levels)</p>
    </div>
  </div>

  <div class="histogram">
    <h3>Brightness Histogram</h3>
    <canvas id="histogramCanvas" width="380" height="100"></canvas>
    <div class="thresholds">
      <span>T1: <span id="t1">64</span></span>
      <span>T2: <span id="t2">128</span></span>
      <span>T3: <span id="t3">192</span></span>
    </div>
    <div class="level-stats">
      <div class="level-stat">
        <div>Level 0</div>
        <div class="value" id="level0">-</div>
      </div>
      <div class="level-stat">
        <div>Level 1</div>
        <div class="value" id="level1">-</div>
      </div>
      <div class="level-stat">
        <div>Level 2</div>
        <div class="value" id="level2">-</div>
      </div>
      <div class="level-stat">
        <div>Level 3</div>
        <div class="value" id="level3">-</div>
      </div>
    </div>
  </div>

  <div class="results">
    <div class="result-row" id="qrDetect">
      <span class="label">QR Detected:</span>
      <span class="value">-</span>
    </div>
    <div class="result-row" id="qrData">
      <span class="label">QR Data:</span>
      <span class="value">-</span>
    </div>
    <div class="result-row">
      <span class="label">Distinct Peaks:</span>
      <span class="value" id="peakCount">-</span>
    </div>
    <div class="result-row">
      <span class="label">Level Separation:</span>
      <span class="value" id="separation">-</span>
    </div>
  </div>

  <div class="note">
    For 4-level encoding to work, histogram should show 4 distinct peaks.<br>
    Good separation = peaks don't overlap. Poor = levels blur together.
  </div>

  <script src="https://unpkg.com/jsqr@1.4.0/dist/jsQR.js"></script>
  <script>
    const video = document.getElementById('video');
    const captureCanvas = document.getElementById('captureCanvas');
    const captureCtx = captureCanvas.getContext('2d', { willReadFrequently: true });
    const startBtn = document.getElementById('startBtn');

    const grayPreview = document.getElementById('grayPreview');
    const grayCtx = grayPreview.getContext('2d');
    const quantizedPreview = document.getElementById('quantizedPreview');
    const quantizedCtx = quantizedPreview.getContext('2d');
    const histogramCanvas = document.getElementById('histogramCanvas');
    const histCtx = histogramCanvas.getContext('2d');

    let scanning = false;

    // Thresholds for 4 levels (will be auto-calculated)
    let thresholds = [64, 128, 192];

    startBtn.addEventListener('click', async () => {
      try {
        video.srcObject = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: 'environment', width: { ideal: 720 }, height: { ideal: 720 } }
        });
        video.play();
        startBtn.disabled = true;
        startBtn.textContent = 'Scanning...';
        scanning = true;
        requestAnimationFrame(scanFrame);
      } catch (err) {
        console.error('Camera error:', err);
        alert('Failed to access camera: ' + err.message);
      }
    });

    function scanFrame() {
      if (!scanning) return;

      if (video.readyState === video.HAVE_ENOUGH_DATA) {
        const size = Math.min(video.videoWidth, video.videoHeight);
        captureCanvas.width = size;
        captureCanvas.height = size;

        const offsetX = (video.videoWidth - size) / 2;
        const offsetY = (video.videoHeight - size) / 2;
        captureCtx.drawImage(video, offsetX, offsetY, size, size, 0, 0, size, size);

        const imageData = captureCtx.getImageData(0, 0, size, size);

        // Convert to grayscale and build histogram
        const histogram = new Array(256).fill(0);
        const grayData = new Uint8ClampedArray(size * size * 4);

        for (let i = 0; i < size * size; i++) {
          const idx = i * 4;
          const r = imageData.data[idx];
          const g = imageData.data[idx + 1];
          const b = imageData.data[idx + 2];
          const gray = Math.round(0.299 * r + 0.587 * g + 0.114 * b);
          histogram[gray]++;
          grayData[idx] = gray;
          grayData[idx + 1] = gray;
          grayData[idx + 2] = gray;
          grayData[idx + 3] = 255;
        }

        // Draw grayscale preview
        const grayImageData = new ImageData(grayData, size, size);
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = size;
        tempCanvas.height = size;
        const tempCtx = tempCanvas.getContext('2d');
        tempCtx.putImageData(grayImageData, 0, 0);
        grayCtx.drawImage(tempCanvas, 0, 0, 150, 150);

        // Find optimal thresholds using multi-Otsu or fixed intervals
        thresholds = findThresholds(histogram, size * size);
        document.getElementById('t1').textContent = thresholds[0];
        document.getElementById('t2').textContent = thresholds[1];
        document.getElementById('t3').textContent = thresholds[2];

        // Quantize to 4 levels
        const quantizedData = new Uint8ClampedArray(size * size * 4);
        const levelCounts = [0, 0, 0, 0];
        const levelValues = [0, 85, 170, 255];

        for (let i = 0; i < size * size; i++) {
          const idx = i * 4;
          const gray = grayData[idx];
          let level;
          if (gray < thresholds[0]) level = 0;
          else if (gray < thresholds[1]) level = 1;
          else if (gray < thresholds[2]) level = 2;
          else level = 3;

          levelCounts[level]++;
          const qVal = levelValues[level];
          quantizedData[idx] = qVal;
          quantizedData[idx + 1] = qVal;
          quantizedData[idx + 2] = qVal;
          quantizedData[idx + 3] = 255;
        }

        // Draw quantized preview
        const quantizedImageData = new ImageData(quantizedData, size, size);
        tempCtx.putImageData(quantizedImageData, 0, 0);
        quantizedCtx.drawImage(tempCanvas, 0, 0, 150, 150);

        // Update level stats
        const total = size * size;
        document.getElementById('level0').textContent = (levelCounts[0] / total * 100).toFixed(1) + '%';
        document.getElementById('level1').textContent = (levelCounts[1] / total * 100).toFixed(1) + '%';
        document.getElementById('level2').textContent = (levelCounts[2] / total * 100).toFixed(1) + '%';
        document.getElementById('level3').textContent = (levelCounts[3] / total * 100).toFixed(1) + '%';

        // Draw histogram
        drawHistogram(histogram, thresholds);

        // Analyze histogram for distinct peaks
        const analysis = analyzeHistogram(histogram);
        document.getElementById('peakCount').textContent = analysis.peaks;
        document.getElementById('separation').textContent = analysis.separation;

        // Try to decode standard QR from grayscale
        const qrCode = jsQR(grayData, size, size);
        const qrDetect = document.getElementById('qrDetect');
        const qrData = document.getElementById('qrData');

        if (qrCode) {
          qrDetect.classList.add('success');
          qrDetect.classList.remove('failure');
          qrDetect.querySelector('.value').textContent = 'Yes';
          qrData.querySelector('.value').textContent = qrCode.data.substring(0, 40) + (qrCode.data.length > 40 ? '...' : '');
        } else {
          qrDetect.classList.add('failure');
          qrDetect.classList.remove('success');
          qrDetect.querySelector('.value').textContent = 'No';
          qrData.querySelector('.value').textContent = '-';
        }
      }

      requestAnimationFrame(scanFrame);
    }

    function findThresholds(histogram, total) {
      // Simple approach: divide range into quartiles based on cumulative distribution
      let cumulative = 0;
      const targets = [total * 0.25, total * 0.5, total * 0.75];
      const result = [64, 128, 192]; // defaults

      let targetIdx = 0;
      for (let i = 0; i < 256 && targetIdx < 3; i++) {
        cumulative += histogram[i];
        if (cumulative >= targets[targetIdx]) {
          result[targetIdx] = i;
          targetIdx++;
        }
      }

      return result;
    }

    function drawHistogram(histogram, thresholds) {
      const width = histogramCanvas.width;
      const height = histogramCanvas.height;
      histCtx.fillStyle = '#1a1a2e';
      histCtx.fillRect(0, 0, width, height);

      // Find max for scaling
      const max = Math.max(...histogram);

      // Draw bars
      histCtx.fillStyle = '#00d4ff';
      const barWidth = width / 256;
      for (let i = 0; i < 256; i++) {
        const barHeight = (histogram[i] / max) * (height - 10);
        histCtx.fillRect(i * barWidth, height - barHeight, barWidth, barHeight);
      }

      // Draw threshold lines
      histCtx.strokeStyle = '#ff6b6b';
      histCtx.lineWidth = 2;
      for (const t of thresholds) {
        const x = (t / 256) * width;
        histCtx.beginPath();
        histCtx.moveTo(x, 0);
        histCtx.lineTo(x, height);
        histCtx.stroke();
      }
    }

    function analyzeHistogram(histogram) {
      // Count peaks (local maxima with significant height)
      const smoothed = [];
      const windowSize = 10;
      for (let i = 0; i < 256; i++) {
        let sum = 0;
        let count = 0;
        for (let j = Math.max(0, i - windowSize); j <= Math.min(255, i + windowSize); j++) {
          sum += histogram[j];
          count++;
        }
        smoothed[i] = sum / count;
      }

      // Find peaks
      const peaks = [];
      const minHeight = Math.max(...smoothed) * 0.1;
      for (let i = 5; i < 251; i++) {
        if (smoothed[i] > smoothed[i - 5] && smoothed[i] > smoothed[i + 5] && smoothed[i] > minHeight) {
          // Check it's not too close to another peak
          if (peaks.length === 0 || i - peaks[peaks.length - 1] > 30) {
            peaks.push(i);
          }
        }
      }

      // Evaluate separation quality
      let separation = 'Poor';
      if (peaks.length >= 4) {
        const gaps = [];
        for (let i = 1; i < peaks.length; i++) {
          gaps.push(peaks[i] - peaks[i - 1]);
        }
        const minGap = Math.min(...gaps);
        if (minGap > 50) separation = 'Excellent';
        else if (minGap > 35) separation = 'Good';
        else if (minGap > 20) separation = 'Fair';
      } else if (peaks.length === 3) {
        separation = 'Fair (3 peaks)';
      } else if (peaks.length === 2) {
        separation = 'Poor (2 peaks)';
      }

      return { peaks: peaks.length, separation };
    }

    console.log('4-Level Grayscale Receiver ready');
  </script>
</body>
</html>
